<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UIView动画]]></title>
    <url>%2F2017%2F08%2F17%2FUIView%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[UIImageView设置动画组123456789// _afterWheel 是一个UIImageViewNSMutableArray* after = [NSMutableArray array];for(int i = 1;i&lt;4;i++)&#123; [after addObject: [UIImage imageNamed:[NSString stringWithFormat:@"resource.bundle/%@%d",@"porche-f",i]]];&#125;_afterWheel.animationImages = after;_afterWheel.animationDuration = 0.05;_afterWheel.animationRepeatCount = 0;[_afterWheel startAnimating];]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer]]></title>
    <url>%2F2017%2F08%2F16%2FCALayer%2F</url>
    <content type="text"><![CDATA[UIView和CALayer的关系UIView是iOS页面控件的基类，因为UIView直接继承自UIResponder，所以可以响应用户事件，在iOS中创建的每一个UIView都有一个属性layer（CALayer），layer继承自己NSObject，不能响应用户事件，但layer提供了UIView内容的绘制功能，也就是说UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。UIView和CALayer相互依赖，UIView依赖于CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容，UIView可以理解为是CALayer的高级封装。 一、基础使用1234567891011121314151617// 边框颜色self.iconView.layer.borderColor = [UIColor orangeColor].CGColor;// 边框宽度self.iconView.layer.borderWidth = 10;// 圆角半径self.iconView.layer.cornerRadius = 10;// 超出图层边框的内容裁剪掉self.iconView.layer.masksToBounds = YES;// 颜色self.iconView.layer.shadowColor = [UIColor blackColor].CGColor;// 偏移量self.iconView.layer.shadowOffset = CGSizeMake(10, 10);// 透明度self.iconView.layer.shadowOpacity = 0.5;// 内容self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 示例：实现UIImageView既能设置圆角,也能设置阴影? 思路：创建两个图层，一个负责圆角,一个负责阴影123456789101112131415161718// 创建背景图层用来设置阴影CALayer *bgLayer = [CALayer layer];bgLayer.frame = CGRectMake(100, 100, 100, 100);bgLayer.backgroundColor = [UIColor clearColor].CGColor;// 设置阴影bgLayer.shadowColor = [UIColor purpleColor].CGColor;bgLayer.shadowOffset = CGSizeMake(10, 10);bgLayer.shadowOpacity = 0.5;// 创建子图层负责显示图片和设置圆角CALayer *subLayer = [CALayer layer];subLayer.frame = bgLayer.bounds;subLayer.cornerRadius = 20;subLayer.masksToBounds = YES;subLayer.contents = (id) [UIImage imageNamed:@"girl.png"].CGImage;[bgLayer addSublayer:subLayer];[self.view.layer addSublayer:bgLayer]; 二、CALayer的transform属性1234567891011121314// 平移self.iconView.layer.transform = CATransform3DMakeTranslation(100, 100, 13210); //缩放self.iconView.layer.transform = CATransform3DMakeScale(0.5, 1, 100);// 旋转self.iconView.layer.transform = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);self.iconView.transform = CGAffineTransformMakeRotation(M_PI_4);// 旋转 100弧度[self.iconView.layer setValue:@(100) forKeyPath:@"transform.rotation.z"];// 全局缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale"];// 指定X轴方向缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale.x"]; 注意：CALayer 还有一个锚点属性.anchorPoint，锚点默认是在图层的中心位置，如果改变锚点，会对图层position属性造成影响。 三、CALayer的隐式动画1234567891011//直接修改layer的大小、位置等一些属性会默认执行动画(subLayer为自定义创建的layer,添加在self.view.layer上)self.subLayer.position = CGPointMake(200, 200);self.subLayer.bounds = CGRectMake(0, 0, 250, 250);// 开启事务[CATransaction begin];// 禁止执行隐式动画[CATransaction setDisableActions:YES];self.subLayer.position = CGPointMake(200, 200);// 提交事务[CATransaction commit]; 我们自己写的动画都属于显式动画，当定义显示动画后，相应的隐式动画会自动取消。 四、CALayer可以动画的属性由于CALayer在iOS中任务主要是内容展示和动画操作，并且动画操作是CALayer的一个重要功能，因此CALayer很多属性的值在变化的时都有动画效果，这个就是我们之前提到的“隐式动画”（手动创建的CALayer对象，都存在着隐式动画），但UIView的根图层是一个例外，根图层属性修改的时候不形成动画效果，因为根图层充当容器的作用，如果它的属性变化形成动画效果会直接干扰子图层。另外，根图层是是由UIView管理，不能重新创建。常用的图层属性请参照苹果开发文档中的CALayer Animatable PropertiesCALayer使用bounds和position属性，position在子图层的位置由anchorPoint决定，frame属性很少使用CALayer透明度使用opacity，而不是alpha 五、CALayer的内容绘制1、使用图片为图层提供内容（适用于图层内容几乎不改变的情况）1self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 2、使用代理提供图层内容如果图层内容是动态改变的，则可以使用代理对象在需要的时候提供图层并更新内容。图层显示的时候，从代理方法获取内容，代理方法主要有以下两个： - (void)displayLayer:(CALayer *)layer; - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 如果实现了displayLayer:方法，实现方法负责创建位图并赋值给contents属性如果实现了drawLayer: inContext:方法，Core Animation创建一个位图，创业一个用于绘制位图的上下文，并调用代理方法填充该位图，代理方法所需要做的是将内容画在图形上下文中。注意：代理对象必须实现以上两个方法之一，如果代理对象把以上两个法都实现了，那么图层需要内容的时候，只调用displayLayer:代理方法。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Animation]]></title>
    <url>%2F2017%2F08%2F16%2FCore-Animation%2F</url>
    <content type="text"><![CDATA[CoreAnimation是iOS与OS X平台上负责图形渲染与动画的基础设施。Core Animation可以动画视图和其他的可视元素，为你完成了动画所需的大部分绘帧工作。只需配置少量的动画参数（如开始点位置和结束点的位置）就可实现绚丽的Core Animation动画效果。 Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且更加的平滑，而且不会加重CPU的负担而影响程序的运行速度。 Core Animation自身并不是一个绘图系统。它只是一个负责在硬件上合成和操纵应用内容的基础构件。Core Animation的核心是图层对象，图层对象用于管理和操控你的应用内容。图层将捕获的内容放到一副位图中，图形硬件能够非常容易的操控你的位图。 当我们平时使用UIView动画不能满足需求的时候，可以直接对UIView的内容绘制的layer进行操作，Core Animation是UIview动画底层的实现，是对CALayer进行操作，所以Core Animation操作的对象是CALayer，而不是UIView。 Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程(执行动画的时候还能点击UI其它控件触发别的事件）。 CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用 CABasicAnimation：基本动画，通过属性修改进行动画参数控制，只有初始状态和结束状态CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行CATransition：转场动画，主要通过滤镜进行动画效果设置 一、CABasicAnimation1234567891011121314151617181920212223CABasicAnimation *anim = [CABasicAnimation animation];// 通过keyPath来告诉layer要执行怎样的动画(旋转,平移,缩放)，该属性必须是layer的一个属性anim.keyPath = @"transform.scale.x";// anim.keyPath = @"transform.rotation.z";// anim.keyPath = @"position"; // anim.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 200)];// anim.keyPath = @"bounds"; // anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 250, 250)];// anim.keyPath = @"transform"; // anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_4, 0, 0, 1)];anim.fromValue = @(4);anim.toValue = @(1.5);// 还可以设置成颜色变化// anim.toValue = (id)[UIColor redColor].CGColor;// 动画结束后不要移除动画效果anim.removedOnCompletion = NO;// 保持动画执行后的状态anim.fillMode = kCAFillModeBoth;// 设置动画的执行时间 （当前动画时间 + 延迟2s执行）anim.beginTime = CACurrentMediaTime() + 2;[self.blueView.layer addAnimation:anim forKey:nil]; 二、CAKeyframeAnimation 1、做一个抖动效果123456789// 角度转换弧度的宏#define angle2Radian(angel) ((angel) * M_PI / 180.0)CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"];anim.values = @[@(angle2Radian(-3)),@(angle2Radian(3)),@(angle2Radian(-3))];anim.repeatCount = MAXFLOAT;anim.duration = 0.2f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;[self.redView.layer addAnimation:anim forKey:@"abc"]; 2、设置关键帧数组values 12345678910111213141516 CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 设置关键帧anim.values = @[[NSValue valueWithCGPoint:CGPointZero], [NSValue valueWithCGPoint:CGPointMake(200, 0)], [NSValue valueWithCGPoint:CGPointMake(200, 200)], [NSValue valueWithCGPoint:CGPointMake(0, 200)], [NSValue valueWithCGPoint:CGPointZero]];// 设置关键帧执行的时间点(每一个元素的取值范围是0到1,后面的值要大于前面的值)anim.keyTimes = @[@(0),@(0.1),@(0.5),@(0.8),@(1)];anim.duration = 2.0f;// 保持动画执行完毕的状态anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;// 设置动画执行节奏anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];[self.redView.layer addAnimation:anim forKey:nil]; 3、设置路径path12345678910CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建一个圆圈路径CGMutablePathRef path = CGPathCreateMutable();CGPathAddEllipseInRect(path, NULL, CGRectMake(100, 100, 250,250));anim.path = path;anim.duration = 2.0f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[self.redView.layer addAnimation:anim forKey:nil]; 三、CAAnimationGroup12345678910111213141516171819202122232425262728293031323334353637383940CAKeyframeAnimation *position = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建路径CGMutablePathRef path = CGPathCreateMutable();// 起始CGPathMoveToPoint(path, NULL, startPoint.x, startPoint.y);// 创建关键控制点数组（数组存放CGRect, CGRect的x、y值作为控制点xy坐标值，width和height作为结束点的xy坐标值） NSMutableArray *pointArrs = [[NSMutableArray alloc] init]; CGFloat width = [UIScreen mainScreen].bounds.size.width / 2; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))]; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))];[pointArrs enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CGRect rect = CGRectFromString(obj); // 二阶贝塞尔曲线 CGPathAddQuadCurveToPoint(path, NULL, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);&#125;];// 结束CGPathAddQuadCurveToPoint(path, NULL, endPoint.x, endPoint.y, endPoint.x, endPoint.y);position.path = path;position.duration = 5.0;position.speed = 0.7;position.removedOnCompletion = NO;position.fillMode = kCAFillModeForwards;CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];scaleAnimation.duration = 1.2;scaleAnimation.beginTime = 0.f;scaleAnimation.fromValue = [NSNumber numberWithFloat:0.7];scaleAnimation.toValue = [NSNumber numberWithFloat:1.5];scaleAnimation.removedOnCompletion = _removedOnCompletion;scaleAnimation.fillMode = kCAFillModeForwards;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];animationGroup.duration = 5+3;animationGroup.removedOnCompletion = NO;animationGroup.fillMode = kCAFillModeForwards;animationGroup.delegate = self;animationGroup.animations = @[position,scaleAnimation];[self.layer addAnimation:animationGroup forKey:@"SpecialGiftCar"]; 三、CATransition12345678910// 1.创建动画对象CATransition *tran = [CATransition animation];// 2.设置转场效果tran.type = @"oglFlip";// 3.设置转场方向tran.subtype = kCATransitionFromRight;NSString *imagename = [NSString stringWithFormat:@"%d",self.index];self.imageView.image = [UIImage imageNamed:imagename];// 4.添加动画到图层上[self.imageView.layer addAnimation:tran forKey:nil]; 附：过渡效果fade //交叉淡化过渡(不支持过渡方向) kCATransitionFadepush //新视图把旧视图推出去 kCATransitionPushmoveIn //新视图移到旧视图上面 kCATransitionMoveInreveal //将旧视图移开,显示下面的新视图 kCATransitionReveal /**下面几个也是过渡效果，但它们是私有API效果，使用的时候要小心，可能会导致app审核不被通过*/cube //立方体翻滚效果oglFlip //上下左右翻转效果suckEffect //收缩效果，如一块布被抽走(不支持过渡方向)rippleEffect //滴水效果(不支持过渡方向)pageCurl //向上翻页效果pageUnCurl //向下翻页效果cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向)cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell实现多选、全选、全不选]]></title>
    <url>%2F2017%2F08%2F07%2FUITableViewCell%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%80%89%E3%80%81%E5%85%A8%E9%80%89%E3%80%81%E5%85%A8%E4%B8%8D%E9%80%89%2F</url>
    <content type="text"><![CDATA[使用场景之一：购物车的时候用到1、设置cell可多选属性1self.tableV.allowsMultipleSelection = YES; 2、设置cell选择状态1cell.selectionStyle = UITableViewCellSelectionStyleNone 3、在cell上自定义一个选择Button(自定义名为：checkBtn)，Button的selected属性跟cell里的selected的属性绑定。设置Button的两种状态：UIControlStateNormal和UIControlStateSelected的不同状态图片。1234- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; self.checkBtn.selected = selected;&#125; 4、获取所有被选中的cell的NSIndexPath数组1NSArray * selectRows = self.tableV.indexPathsForSelectedRows; 5、全选/取消全选1234567891011if (select) &#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone]; &#125; &#125;else&#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV deselectRowAtIndexPath:indexPath animated:YES]; &#125; &#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天周末，兴致所致，想做一个素雅无任何广告的博客，用来记录一点生活和学习相关的东西，便有了此博客的诞生。 这是使用Github Pages + Hexo 搭建的博客。 在此感谢 Github , 感谢 Hexo , 感谢 Line 的博客搭建教学。 基础命令1、如何创建博客文章？ 1$ hexo new "我的第一篇博客" 更多指令信息可查看文档: Writing 2、 清理缓存 1$ hexo clean 网页正常情况下可以忽略此条命令 3、 生成静态网页 1$ hexo generate 默认生成的静态网页放在public目录博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作只要输入hexo generate命令即可，hexo会帮我们完成转换。Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 语法说明 4、 开启预览访问端口 1$ hexo server 默认端口4000，’ctrl + c’关闭server 5、 将.deploy目录部署到GitHub 1$ hexo deploy 文档编辑1、写标题12### 一、我是标题#### 1、我也是标题 2、插入图片（图片可以托管在七牛上，也可以放在hexo的资源文件夹里）1![Image text](http://ouakkqmoq.bkt.clouddn.com/coreAnimation.png) 3、不完全显示文章内容，在适当位置添加“查看全部”按钮1&lt;!--more--&gt; 4、写代码123``` bash这里是代码内容(```)只有三个点，没有这个括号]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
