<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[runtime]]></title>
    <url>%2F2017%2F08%2F17%2Fruntime%2F</url>
    <content type="text"><![CDATA[runtime是一套底层的C语言API（包含很多强大实用的C语言数据类型、C语言函数）运行时最主要的消息机制，是使用c语言给对象发送消息,对象接收到消息后, 找到匹配的方法执行。 常见的函数、头文件123456#import &lt;objc/runtime.h&gt; : 成员变量、类、方法Ivar * class_copyIvarList : 获得某个类内部的所有成员变量Method * class_copyMethodList : 获得某个类内部的所有方法Method class_getInstanceMethod : 获得某个实例方法Method class_getClassMethod : 获得某个类方法method_exchangeImplementations : 交换2个方法的具体实现 应用场景1：字典转模型1234567891011121314151617NSDictionary *dict =@&#123;@"name":@"普京",@"age":@18,@"score":@59&#125;;// 1、搜索类里的成员变量unsigned int count = 0;// 获取这个类所有的成员变量Ivar *Ivars = class_copyIvarList([XRPerson class], &amp;count);XRPerson *person = [[XRPerson alloc]init];for (int i = 0; i&lt;count; i++) &#123; Ivar ivar =Ivars[i]; const char *type =ivar_getTypeEncoding(ivar);//获取成员变量的类型，这里没用到 const char *name = ivar_getName(ivar);// 2、C语言转OC，去掉成员变量的下划线"_" NSMutableString *strM =[[NSMutableString alloc]initWithString:[NSString stringWithUTF8String:name]]; NSString *resultStr =[strM substringFromIndex:1];// 3、通过KVC为成员变量赋值 [person setValue:dict[resultStr] forKey:resultStr];&#125;NSLog(@"%@ %d %.2lf",person.name,person.age,person.score); 应用场景2：归档解档当你想把某个类里的所有成员变量拿出来做一些事情，或者成员变量非常多，你就可以利用运行时一次性的对这个类的所有成员变量进行归档解档。12345678910- (void)encodeWithCoder:(NSCoder *)encoder&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([XRPerson class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; Ivar ivar = ivars[i]; const char *name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; [encoder encodeObject:[self valueForKeyPath:key] forKey:key]; &#125;&#125; 应用场景3：交换2个方法的实现（Method Swizzle）method_exchangeImplementations 交换2个方法的中的实现class_replaceMethod 修改类method_setImplementation 直接设置某个方法的实现 1、当你想对系统的方法做一些手脚，添加或者修改些什么的时候，就可以用runtime交换2方法的实现 2、旧项目用的是imageNamed方法通过简单判断来适配图片的，图片多了，重复代码很垃圾，难更改，难维护。解决方案：利用运行时交换两个方法的实现。写一个image分类，用分类写的方法与系统的方法实现交换了。123456789101112131415161718192021#import &lt;objc/runtime.h&gt;@implementation UIImage (Extension)+(void)load&#123; // 只要分类被装载到内存中，就会调用1次 Method originMethod = class_getClassMethod(self, @selector(imageNamed:)); Method otherMethod = class_getClassMethod(self, @selector(imageWithName:));// 交换2个方法的实现 method_exchangeImplementations(originMethod, otherMethod);&#125;+(UIImage *)imageWithName:(NSString *)name&#123; BOOL iOS8 = [[UIDevice currentDevice].systemVersion floatValue]&gt;=8.0; UIImage *image =nil; if (iOS8) &#123; NSString *newName=[name stringByAppendingString:@"_os8"]; image=[UIImage imageWithName:newName]; &#125; if (image==nil) &#123; image =[UIImage imageWithName:name]; &#125; return image;&#125; 4、屏蔽数组传nil报错,数组越界报错（负面效果是难找到报错，谨慎实用，看场合，权衡使用）解决方案：利用运行时的交换方法的实现的办法（1）只要外面传nil，我在内部就不管它，（2）或者自己打印出来哪里传了nil，这样我们就能发现错在哪，要不然找不到报错的地方。（3）还可以在里面做一些自己想做的事，过滤一些东西，比如：只有传的是string类型的，我才添加到数组中。 5、屏蔽字典传空错误 注意：多个有继承关系的类对象swizzle时，先从父对象开始，这样才能保证子类方法拿到父类中的被swizzle的实现。在+（viod）load中swizzle不会出错，就是因为load类方法会默认从父类开始调用。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView动画]]></title>
    <url>%2F2017%2F08%2F17%2FUIView%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[UIView动画实质上是对Core Animation的封装，提供简洁的动画接口。对于简单的应用场景，使用UIView动画非常方便简洁。 一、基础动画12345678[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 delay:(NSTimeInterval) //动画延迟执行的时间 options:(UIViewAnimationOptions) //动画的过渡效果 animations:^&#123; //执行的动画 &#125; completion:^(BOOL finished) &#123; //动画执行完毕后的操作 &#125;]; UIViewAnimationOptions的枚举值如下，可组合使用：123456789101112131415161718192021222324UIViewAnimationOptionLayoutSubviews //进行动画时布局子控件 UIViewAnimationOptionAllowUserInteraction //进行动画时允许用户交互 UIViewAnimationOptionBeginFromCurrentState //从当前状态开始动画 UIViewAnimationOptionRepeat //无限重复执行动画 UIViewAnimationOptionAutoreverse //执行动画回路 UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置 UIViewAnimationOptionOverrideInheritedCurve //忽略嵌套动画的曲线设置 UIViewAnimationOptionAllowAnimatedContent //转场：进行动画时重绘视图 UIViewAnimationOptionShowHideTransitionViews //转场：移除（添加和移除图层的）动画效果 UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置 UIViewAnimationOptionCurveEaseInOut //时间曲线，慢进慢出（默认值） UIViewAnimationOptionCurveEaseIn //时间曲线，慢进 UIViewAnimationOptionCurveEaseOut //时间曲线，慢出 UIViewAnimationOptionCurveLinear //时间曲线，匀速 UIViewAnimationOptionTransitionNone //转场，不使用动画 UIViewAnimationOptionTransitionFlipFromLeft //转场，从左向右旋转翻页 UIViewAnimationOptionTransitionFlipFromRight //转场，从右向左旋转翻页 UIViewAnimationOptionTransitionCurlUp //转场，下往上卷曲翻页 UIViewAnimationOptionTransitionCurlDown //转场，从上往下卷曲翻页 UIViewAnimationOptionTransitionCrossDissolve //转场，交叉消失和出现 UIViewAnimationOptionTransitionFlipFromTop //转场，从上向下旋转翻页 UIViewAnimationOptionTransitionFlipFromBottom //转场，从下向上旋转翻页 二、Spring动画1234567891011[UIView animateWithDuration:(NSTimeInterval) delay:(NSTimeInterval) usingSpringWithDamping:(CGFloat)//震动效果，范围0~1，数值越小震动效果越明显 initialSpringVelocity:(CGFloat)//初始速度，数值越大初始速度越快 options:(UIViewAnimationOptions) animations:^&#123; &#125; completion:^(BOOL finished) &#123; &#125;]; 三、Keyframes动画只支持属性关键帧，不支持路径关键帧123456789[UIView animateKeyframesWithDuration:(NSTimeInterval) delay:(NSTimeInterval) options:(UIViewKeyframeAnimationOptions) animations:^&#123; //执行的关键帧动画 &#125; completion:^(BOOL finished) &#123; &#125;]; 增加关键帧的方法：12345[UIView addKeyframeWithRelativeStartTime:(double)//动画开始的时间（占总时间的比例） relativeDuration:(double) //动画持续时间（占总时间的比例） animations:^&#123; //执行的动画 &#125;]; UIViewKeyframeAnimationOptions的枚举值如下，可组合使用：12345678910111213UIViewAnimationOptionLayoutSubviews //进行动画时布局子控件UIViewAnimationOptionAllowUserInteraction //进行动画时允许用户交互UIViewAnimationOptionBeginFromCurrentState //从当前状态开始动画UIViewAnimationOptionRepeat //无限重复执行动画UIViewAnimationOptionAutoreverse //执行动画回路UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置UIViewKeyframeAnimationOptionCalculationModeLinear //运算模式 :连续UIViewKeyframeAnimationOptionCalculationModeDiscrete //运算模式 :离散UIViewKeyframeAnimationOptionCalculationModePaced //运算模式 :均匀执行UIViewKeyframeAnimationOptionCalculationModeCubic //运算模式 :平滑UIViewKeyframeAnimationOptionCalculationModeCubicPaced //运算模式 :平滑均匀 四、转场动画1、单个视图的过渡效果123456789[UIView transitionWithView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) animations:^&#123; &#125; completion:^(BOOL finished) &#123; &#125;]; 2、从旧视图转场到新视图的动画效果1234567[UIView transitionFromView:(nonnull UIView *) toView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) completion:^(BOOL finished) &#123; &#125;]; // toView added to fromView.superview, fromView removed from its superview 五、UIImageView设置图片帧动画123456789// _afterWheel 是一个UIImageViewNSMutableArray* after = [NSMutableArray array];for(int i = 1;i&lt;4;i++)&#123; [after addObject: [UIImage imageNamed:[NSString stringWithFormat:@"resource.bundle/%@%d",@"porche-f",i]]];&#125;_afterWheel.animationImages = after;_afterWheel.animationDuration = 0.05;_afterWheel.animationRepeatCount = 0;[_afterWheel startAnimating];]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer]]></title>
    <url>%2F2017%2F08%2F16%2FCALayer%2F</url>
    <content type="text"><![CDATA[UIView和CALayer的关系UIView是iOS页面控件的基类，因为UIView直接继承自UIResponder，所以可以响应用户事件，在iOS中创建的每一个UIView都有一个属性layer（CALayer），layer继承自己NSObject，不能响应用户事件，但layer提供了UIView内容的绘制功能，也就是说UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。UIView和CALayer相互依赖，UIView依赖于CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容，UIView可以理解为是CALayer的高级封装。 一、基础使用1234567891011121314151617// 边框颜色self.iconView.layer.borderColor = [UIColor orangeColor].CGColor;// 边框宽度self.iconView.layer.borderWidth = 10;// 圆角半径self.iconView.layer.cornerRadius = 10;// 超出图层边框的内容裁剪掉self.iconView.layer.masksToBounds = YES;// 颜色self.iconView.layer.shadowColor = [UIColor blackColor].CGColor;// 偏移量self.iconView.layer.shadowOffset = CGSizeMake(10, 10);// 透明度self.iconView.layer.shadowOpacity = 0.5;// 内容self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 示例：实现UIImageView既能设置圆角,也能设置阴影? 思路：创建两个图层，一个负责圆角,一个负责阴影123456789101112131415161718// 创建背景图层用来设置阴影CALayer *bgLayer = [CALayer layer];bgLayer.frame = CGRectMake(100, 100, 100, 100);bgLayer.backgroundColor = [UIColor clearColor].CGColor;// 设置阴影bgLayer.shadowColor = [UIColor purpleColor].CGColor;bgLayer.shadowOffset = CGSizeMake(10, 10);bgLayer.shadowOpacity = 0.5;// 创建子图层负责显示图片和设置圆角CALayer *subLayer = [CALayer layer];subLayer.frame = bgLayer.bounds;subLayer.cornerRadius = 20;subLayer.masksToBounds = YES;subLayer.contents = (id) [UIImage imageNamed:@"girl.png"].CGImage;[bgLayer addSublayer:subLayer];[self.view.layer addSublayer:bgLayer]; 二、CALayer的transform属性1234567891011121314// 平移self.iconView.layer.transform = CATransform3DMakeTranslation(100, 100, 13210); //缩放self.iconView.layer.transform = CATransform3DMakeScale(0.5, 1, 100);// 旋转self.iconView.layer.transform = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);self.iconView.transform = CGAffineTransformMakeRotation(M_PI_4);// 旋转 100弧度[self.iconView.layer setValue:@(100) forKeyPath:@"transform.rotation.z"];// 全局缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale"];// 指定X轴方向缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale.x"]; 注意：CALayer 还有一个锚点属性.anchorPoint，锚点默认是在图层的中心位置，如果改变锚点，会对图层position属性造成影响。 三、CALayer的隐式动画1234567891011//直接修改layer的大小、位置等一些属性会默认执行动画(subLayer为自定义创建的layer,添加在self.view.layer上)self.subLayer.position = CGPointMake(200, 200);self.subLayer.bounds = CGRectMake(0, 0, 250, 250);// 开启事务[CATransaction begin];// 禁止执行隐式动画[CATransaction setDisableActions:YES];self.subLayer.position = CGPointMake(200, 200);// 提交事务[CATransaction commit]; 我们自己写的动画都属于显式动画，当定义显示动画后，相应的隐式动画会自动取消。 四、CALayer可以动画的属性由于CALayer在iOS中任务主要是内容展示和动画操作，并且动画操作是CALayer的一个重要功能，因此CALayer很多属性的值在变化的时都有动画效果，这个就是我们之前提到的“隐式动画”（手动创建的CALayer对象，都存在着隐式动画），但UIView的根图层是一个例外，根图层属性修改的时候不形成动画效果，因为根图层充当容器的作用，如果它的属性变化形成动画效果会直接干扰子图层。另外，根图层是是由UIView管理，不能重新创建。常用的图层属性请参照苹果开发文档中的CALayer Animatable PropertiesCALayer使用bounds和position属性，position在子图层的位置由anchorPoint决定，frame属性很少使用CALayer透明度使用opacity，而不是alpha 五、CALayer的内容绘制1、使用图片为图层提供内容（适用于图层内容几乎不改变的情况）1self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 2、使用代理提供图层内容如果图层内容是动态改变的，则可以使用代理对象在需要的时候提供图层并更新内容。图层显示的时候，从代理方法获取内容，代理方法主要有以下两个： - (void)displayLayer:(CALayer *)layer; - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 如果实现了displayLayer:方法，实现方法负责创建位图并赋值给contents属性如果实现了drawLayer: inContext:方法，Core Animation创建一个位图，创业一个用于绘制位图的上下文，并调用代理方法填充该位图，代理方法所需要做的是将内容画在图形上下文中。注意：代理对象必须实现以上两个方法之一，如果代理对象把以上两个法都实现了，那么图层需要内容的时候，只调用displayLayer:代理方法。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Animation]]></title>
    <url>%2F2017%2F08%2F16%2FCore-Animation%2F</url>
    <content type="text"><![CDATA[CoreAnimation是iOS与OS X平台上负责图形渲染与动画的基础设施。Core Animation可以动画视图和其他的可视元素，为你完成了动画所需的大部分绘帧工作。只需配置少量的动画参数（如开始点位置和结束点的位置）就可实现绚丽的Core Animation动画效果。 Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且更加的平滑，而且不会加重CPU的负担而影响程序的运行速度。 Core Animation自身并不是一个绘图系统。它只是一个负责在硬件上合成和操纵应用内容的基础构件。Core Animation的核心是图层对象，图层对象用于管理和操控你的应用内容。图层将捕获的内容放到一副位图中，图形硬件能够非常容易的操控你的位图。 当我们平时使用UIView动画不能满足需求的时候，可以直接对UIView的内容绘制的layer进行操作，Core Animation是UIview动画底层的实现，是对CALayer进行操作，所以Core Animation操作的对象是CALayer，而不是UIView。 Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程(执行动画的时候还能点击UI其它控件触发别的事件）。 CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用 CABasicAnimation：基本动画，通过属性修改进行动画参数控制，只有初始状态和结束状态CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行CATransition：转场动画，主要通过滤镜进行动画效果设置 一、CABasicAnimation1234567891011121314151617181920212223CABasicAnimation *anim = [CABasicAnimation animation];// 通过keyPath来告诉layer要执行怎样的动画(旋转,平移,缩放)，该属性必须是layer的一个属性anim.keyPath = @"transform.scale.x";// anim.keyPath = @"transform.rotation.z";// anim.keyPath = @"position"; // anim.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 200)];// anim.keyPath = @"bounds"; // anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 250, 250)];// anim.keyPath = @"transform"; // anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_4, 0, 0, 1)];anim.fromValue = @(4);anim.toValue = @(1.5);// 还可以设置成颜色变化// anim.toValue = (id)[UIColor redColor].CGColor;// 动画结束后不要移除动画效果anim.removedOnCompletion = NO;// 保持动画执行后的状态anim.fillMode = kCAFillModeBoth;// 设置动画的执行时间 （当前动画时间 + 延迟2s执行）anim.beginTime = CACurrentMediaTime() + 2;[self.blueView.layer addAnimation:anim forKey:nil]; 二、CAKeyframeAnimation 1、做一个抖动效果123456789// 角度转换弧度的宏#define angle2Radian(angel) ((angel) * M_PI / 180.0)CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"];anim.values = @[@(angle2Radian(-3)),@(angle2Radian(3)),@(angle2Radian(-3))];anim.repeatCount = MAXFLOAT;anim.duration = 0.2f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;[self.redView.layer addAnimation:anim forKey:@"abc"]; 2、设置关键帧数组values 12345678910111213141516 CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 设置关键帧anim.values = @[[NSValue valueWithCGPoint:CGPointZero], [NSValue valueWithCGPoint:CGPointMake(200, 0)], [NSValue valueWithCGPoint:CGPointMake(200, 200)], [NSValue valueWithCGPoint:CGPointMake(0, 200)], [NSValue valueWithCGPoint:CGPointZero]];// 设置关键帧执行的时间点(每一个元素的取值范围是0到1,后面的值要大于前面的值)anim.keyTimes = @[@(0),@(0.1),@(0.5),@(0.8),@(1)];anim.duration = 2.0f;// 保持动画执行完毕的状态anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;// 设置动画执行节奏anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];[self.redView.layer addAnimation:anim forKey:nil]; 3、设置路径path12345678910CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建一个圆圈路径CGMutablePathRef path = CGPathCreateMutable();CGPathAddEllipseInRect(path, NULL, CGRectMake(100, 100, 250,250));anim.path = path;anim.duration = 2.0f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[self.redView.layer addAnimation:anim forKey:nil]; 三、CAAnimationGroup12345678910111213141516171819202122232425262728293031323334353637383940CAKeyframeAnimation *position = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建路径CGMutablePathRef path = CGPathCreateMutable();// 起始CGPathMoveToPoint(path, NULL, startPoint.x, startPoint.y);// 创建关键控制点数组（数组存放CGRect, CGRect的x、y值作为控制点xy坐标值，width和height作为结束点的xy坐标值） NSMutableArray *pointArrs = [[NSMutableArray alloc] init]; CGFloat width = [UIScreen mainScreen].bounds.size.width / 2; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))]; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))];[pointArrs enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CGRect rect = CGRectFromString(obj); // 二阶贝塞尔曲线 CGPathAddQuadCurveToPoint(path, NULL, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);&#125;];// 结束CGPathAddQuadCurveToPoint(path, NULL, endPoint.x, endPoint.y, endPoint.x, endPoint.y);position.path = path;position.duration = 5.0;position.speed = 0.7;position.removedOnCompletion = NO;position.fillMode = kCAFillModeForwards;CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];scaleAnimation.duration = 1.2;scaleAnimation.beginTime = 0.f;scaleAnimation.fromValue = [NSNumber numberWithFloat:0.7];scaleAnimation.toValue = [NSNumber numberWithFloat:1.5];scaleAnimation.removedOnCompletion = _removedOnCompletion;scaleAnimation.fillMode = kCAFillModeForwards;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];animationGroup.duration = 5+3;animationGroup.removedOnCompletion = NO;animationGroup.fillMode = kCAFillModeForwards;animationGroup.delegate = self;animationGroup.animations = @[position,scaleAnimation];[self.layer addAnimation:animationGroup forKey:@"SpecialGiftCar"]; 三、CATransition12345678910// 1.创建动画对象CATransition *tran = [CATransition animation];// 2.设置转场效果tran.type = @"oglFlip";// 3.设置转场方向tran.subtype = kCATransitionFromRight;NSString *imagename = [NSString stringWithFormat:@"%d",self.index];self.imageView.image = [UIImage imageNamed:imagename];// 4.添加动画到图层上[self.imageView.layer addAnimation:tran forKey:nil]; 附：过渡效果fade //交叉淡化过渡(不支持过渡方向) kCATransitionFadepush //新视图把旧视图推出去 kCATransitionPushmoveIn //新视图移到旧视图上面 kCATransitionMoveInreveal //将旧视图移开,显示下面的新视图 kCATransitionReveal /**下面几个也是过渡效果，但它们是私有API效果，使用的时候要小心，可能会导致app审核不被通过*/cube //立方体翻滚效果oglFlip //上下左右翻转效果suckEffect //收缩效果，如一块布被抽走(不支持过渡方向)rippleEffect //滴水效果(不支持过渡方向)pageCurl //向上翻页效果pageUnCurl //向下翻页效果cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向)cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell实现多选、全选、全不选]]></title>
    <url>%2F2017%2F08%2F07%2FUITableViewCell%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%80%89%E3%80%81%E5%85%A8%E9%80%89%E3%80%81%E5%85%A8%E4%B8%8D%E9%80%89%2F</url>
    <content type="text"><![CDATA[使用场景之一：购物车的时候用到1、设置cell可多选属性1self.tableV.allowsMultipleSelection = YES; 2、设置cell选择状态1cell.selectionStyle = UITableViewCellSelectionStyleNone 3、在cell上自定义一个选择Button(自定义名为：checkBtn)，Button的selected属性跟cell里的selected的属性绑定。设置Button的两种状态：UIControlStateNormal和UIControlStateSelected的不同状态图片。1234- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; self.checkBtn.selected = selected;&#125; 4、获取所有被选中的cell的NSIndexPath数组1NSArray * selectRows = self.tableV.indexPathsForSelectedRows; 5、全选/取消全选1234567891011if (select) &#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone]; &#125; &#125;else&#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV deselectRowAtIndexPath:indexPath animated:YES]; &#125; &#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天周末，兴致所致，想做一个素雅无任何广告的博客，用来记录一点生活和学习相关的东西，便有了此博客的诞生。 这是使用Github Pages + Hexo 搭建的博客。 在此感谢 Github , 感谢 Hexo , 感谢 Line 的博客搭建教学。 基础命令1、如何创建博客文章？ 1$ hexo new "我的第一篇博客" 更多指令信息可查看文档: Writing 2、 清理缓存 1$ hexo clean 网页正常情况下可以忽略此条命令 3、 生成静态网页 1$ hexo generate 默认生成的静态网页放在public目录博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作只要输入hexo generate命令即可，hexo会帮我们完成转换。Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 语法说明 4、 开启预览访问端口 1$ hexo server 默认端口4000，’ctrl + c’关闭server 5、 将.deploy目录部署到GitHub 1$ hexo deploy 文档编辑1、写标题12### 一、我是标题#### 1、我也是标题 2、插入图片（图片可以托管在七牛上，也可以放在hexo的资源文件夹里）1![Image text](http://ouakkqmoq.bkt.clouddn.com/coreAnimation.png) 3、不完全显示文章内容，在适当位置添加“查看全部”按钮1&lt;!--more--&gt; 4、写代码123``` bash这里是代码内容(```)只有三个点，没有这个括号]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
