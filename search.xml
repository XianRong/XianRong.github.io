<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactiveSwift示例]]></title>
    <url>%2F2017%2F09%2F13%2FReactiveSwift%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1、UIButton监听点击123btn.reactive.controlEvents(.touchUpInside).observeValues &#123; (btn) in print("点到我了")&#125; 2、UItextfield监听123456789101112131415161718 // 监听tf的输入值tf.reactive.continuousTextValues.observeValues &#123; (text) in print(text ?? "")&#125;&lt;!--more--&gt;// 监听tf的输入长度tf.reactive.continuousTextValues.map &#123; (text) -&gt; Int in return text!.characters.count&#125;.observeValues &#123; (count) in print(count)&#125;// 当输入字符长度大于3时，才会接收到信息tf.reactive.continuousTextValues.filter &#123; (text) -&gt; Bool in return text!.characters.count&gt;3&#125;.observeValues &#123; (text) in print(text ?? "")&#125; 3、监听UIViewController的viewWillAppear方法123self.reactive.trigger(for: #selector(UIViewController.viewWillAppear(_:))).observeValues &#123; () in print("viewWillAppear被调用了哦")&#125; 4、在OneVC里，监听TwoVC的deinit12345let twoVC = TwoVC()twoVC.reactive.lifetime.ended.observeCompleted &#123; print("textVC已成功销毁")&#125;navigationController?.pushViewController(twoVC, animated: true)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播试炼]]></title>
    <url>%2F2017%2F09%2F10%2F%E7%9B%B4%E6%92%AD%E8%AF%95%E7%82%BC%2F</url>
    <content type="text"><![CDATA[直播APP主要实现的流程1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动 直播APP架构 直播APP技术点 已有框架的支撑1、视频采集端LFLiveKit：一个OC写的可读性非常好的开源推流框架 2、视频处理框架GPUImage：一个基于OpenGL ES的一个强大的图像/视频处理框架,封装好了各种滤镜同时也可以编写自定义的滤镜,其本身内置了多达120多种常见的滤镜效果。 美颜功能也可以直接使用的是BeautifyFace，它可以很快速的实现美颜功能，效果不错，它的底层还是基于的GPUImage 3、视频播放端ijkplayer:一个基于FFmpeg的开源Android/iOS视频播放器把ijkplayer编译成对应使用的平台，最好把IJKMediaPlayer打包成静态库，然后倒入到项目中，有直播的拉流地址就可以播放啦映客主播url:http://116.211.167.106/api/live/aggregation?uid=133825214&amp;interest=1 FFmpeg：是一个跨平台的开源视频框架,能实现如视频编码,解码,转码,串流,播放等丰富的功能。其支持的视频格式以及播放协议非常丰富,几乎包含了所有音视频编解码、封装格式以及播放协议。 4、配置流媒体服务器尝试在Mac上搭建nginx+rtmp服务器nginx:免费开源web服务器，用它来做hls或者rtmp流媒体服务器是非常不错 5、聊天互动使用网易云信、腾讯云、融云等第三方SDK]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>Live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS项目架构]]></title>
    <url>%2F2017%2F09%2F10%2FiOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[MVCMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写是 苹果官方文档 推荐使用的一个设计模式，经典中的经典。看懂斯坦福公开课上的这张图就够了 控制器可以直接访问模型数据，控制器通过懒加载数据，再把数据给view展示 为了保持model和View的重用性，M和V都不能直接拥有C，M和C之间也不能相互访问。 view展示什么数据，只有控制器知道，view是通过控制器的数据源来获得数据 model只负责提供数据，不关心数据展示在哪里。 M不知道V的存在，V不知道M的存在，他们2个只能通过C建立联系 个人体会：简单明了够清晰。加上写分类，抽取工具类，按需抽取业务manager就挺好的。MVC是一个非常成熟的架构，在业务开始复杂的时候，合理的将网络请求，数据持久化等相关与控制器耦合不严重的公共抽取出来，足够满足日常开发需求。例如：网络请求数据，可以先对AFN框架进行通用基础封装，再进行业务层封装，使用block回调数据。 MVVM从广义上讲，MVVM也属于MVC的编程思想范畴，它是把业务逻辑抽取成一个VM模块，减轻C的压力，弱化C，以便于重用和测试，且兼容MVC 最近用Swift写项目用MVVM，配上Extension，感觉挺爽的。 MVVM With RACReactiveCocoa简称RAC，是由Github开源的一个应用于iOS和OS开发的新框架。RAC吸纳了函数式编程(Funtional Programming)和响应式编程(Reactive Programing)的编程思想，它也被描述为函数响应式编程（FRP）框架。RAC最大的优点是 提供了一个单一的、统一的方法去处理异步的行为，包括 Delegate，Blocks Callbacks，Target-Action机制，Notifications和KVO。它最大的与众不同是提供了一种新的写代码的思维，由于RAC将Cocoa中KVO、UIKit Event、Delegate、Selector等都增加了RAC支持，所以都不用去做很多跨函数的事，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。。推荐参考学习的博文：最快让你上手ReactiveCocoa之基础篇最快让你上手ReactiveCocoa之进阶篇美团点评技术团队的博文 保留经典的MVC模式，而对View Controller进行改进方案请参阅喵神的这篇博文：单向数据流动的函数式 View Controller 小结：本人觉得在公司开发实际项目，最重要的还是一个稳字，平时练习学习项目可以多做尝试。]]></content>
      <categories>
        <category>comprehensive</category>
      </categories>
      <tags>
        <tag>comprehensive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播小总结]]></title>
    <url>%2F2017%2F09%2F08%2F%E7%9B%B4%E6%92%AD%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今年接触了一个秀场直播项目，在此做一下简单小总结。 一、功能介绍1、直播列表：关注、热门、明星、同城等等2、排行榜：贡献榜、财富榜3、商城：商品展示、购物车，订单地址管理、订单状态、支付宝微信支付4、直播端：录制、推流、美颜、背景音乐、分享，主播对观众的禁言、拉黑、设置管理员等5、观看端：单聊、聊天室、私聊、@TA,点亮爱心，举报、个人名片、个人主页等6、礼物：普通礼物、特效礼物、实体礼物、充值、提现、内购等7、用户逻辑：手机账号注册登陆、第三方账号登录、个人信息编辑、设置管理、直播回看、关注列表、粉丝列表、我的收益、我的礼物、等级、认证等8、管理后台：审核、禁播等等 二、架构1、使用最经典的MVC架构。（MVC是一个非常成熟的架构，在业务开始复杂的时候，合理的将网络请求，数据持久化等相关与控制器耦合不严重的公共抽取出来，足够满足日常开发需求）2、部分业务逻辑采用抽取manager来管理（比如：收发信息、请求发送礼物、礼物动画）3、网络请求业务，先对AFN框架进行通用基础封装，再进行业务层封装，使用block回调数据。4、项目结构图简图待续… 功能实现待续… 部分业务思路流程待续…]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>Live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIBezierPath]]></title>
    <url>%2F2017%2F08%2F19%2FUIBezierPath%2F</url>
    <content type="text"><![CDATA[1、Bezier// cpx:控制点的x cpy:控制点的y x:结束点的x y:结束点的yCGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz2D]]></title>
    <url>%2F2017%2F08%2F18%2FQuartz2D%2F</url>
    <content type="text"><![CDATA[Quartz 2D是一个二维图形绘制引擎，我们可以使用Quartz 2D 实现基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。在需要的时候，Quartz 2D还可以借助图形硬件的功能。 一、自定义View利用Quartz 2D绘制东西到View上，首先要有图形上下文用于保存绘图信息，再把内容绘制到View上。自定义View的步骤：1、新建一个继承自UIView的类；2、实现- (void)drawRect:(CGRect)rect方法，在这个方法中实现自定义； 获取跟当前View想关联的图形上下文 绘制相应的图形内容 利用图形上下文将绘制的所有内容渲染显示到View上面123456789// 当view第一次显示的时候调用,rect == self.bounds,该方法不能手动调用,只能让系统自动调用- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 获得图形上下文 CGContextAddRect(ctx, CGRectMake(100, 100, 200, 200)); //绘制矩形 // CGContextSetRGBStrokeColor(ctx, 0, 1, 0, 1.0);// 边界颜色 CGContextSetRGBFillColor(ctx, 0, 1, 0, 1); //填充颜色 // CGContextStrokePath(ctx);// 渲染边界 CGContextFillPath(ctx); // 渲染填充&#125; 二、基础绘图第一步：获得图形上下文CGContextRef ctx = UIGraphicsGetCurrentContext();第二步：设置图形信息、图形状态第三步：把图形信息渲染到View上CGContextStrokePath(ctx); 边界CGContextFillPath(ctx); 填充CGContextDrawPath(ctx, kCGPathFillStroke); 边界和填充绘制线条只能以边界形式绘制,不能填充 1、绘制线条1234567891011CGContextRef ctx = UIGraphicsGetCurrentContext();// 绘制第一条线CGContextMoveToPoint(ctx, 100, 100); //设置起点CGContextAddLineToPoint(ctx, 200, 200); //添加一条直线到终点CGContextSetLineWidth(ctx, 10); // 设置线条宽度CGContextSetRGBStrokeColor(ctx, 1.0, 0, 0, 1.0); // 设置线条颜色CGContextSetLineCap(ctx, kCGLineCapRound); // 设置线条两端样式（加帽子）// 绘制第二条线CGContextAddLineToPoint(ctx, 300, 50); // 该方法会自动连接上一条线的终点CGContextSetLineJoin(ctx, kCGLineJoinRound); // 设置线条转折点样式CGContextStrokePath(ctx); 2、绘制三角形1234567891011121314CGContextRef ctx = UIGraphicsGetCurrentContext();// 第一条线CGContextMoveToPoint(ctx, 100, 100);CGContextAddLineToPoint(ctx, 200, 200);CGContextSetLineWidth(ctx, 10); CGContextSetRGBStrokeColor(ctx, 1.0, 0, 0, 1.0); CGContextSetLineCap(ctx, kCGLineCapRound); // 绘制第二条线CGContextAddLineToPoint(ctx, 300, 50);CGContextSetLineJoin(ctx, kCGLineJoinRound);// 绘制第三条线// CGContextAddLineToPoint(ctx, 100, 100);// 该方法会自动连接上一条线的终点CGContextClosePath(ctx);// 该方法会自动连接起点和终点CGContextStrokePath(ctx); 3、绘制圆、圆弧1234567CGContextRef ctx = UIGraphicsGetCurrentContext();// CGContextAddEllipseInRect(ctx, CGRectMake(10, 10, 100, 100)); // 圆CGContextAddEllipseInRect(ctx, CGRectMake(10, 10, 150, 100)); // 椭圆// [[UIColor yellowColor] set]; // 统一设置颜色[[UIColor yellowColor] setFill]; // 设置填充颜色[[UIColor redColor] setStroke]; // 设置边界颜色CGContextDrawPath(ctx, kCGPathFillStroke); 绘制弧的方法坐标是以X轴的正坐标方向为角度0开始计算 c 当前图形上下文 x 圆心的x值 y 圆心的y值 radius 半径 startAngle 开始角度 endAngle 结束角度 clockwise 绘制方向:0:表示顺时针,1:表示逆时针CGContextAddArc(CGContextRef _Nullable c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)12345CGContextRef ctx = UIGraphicsGetCurrentContext();CGFloat centerX = rect.size.width * 0.5;CGFloat centerY = rect.size.height * 0.5;CGContextAddArc(ctx, centerX, centerY, 50, 0 , 2 * M_PI , 0); CGContextStrokePath(ctx); 4、绘制图片123456- (void)drawRect:(CGRect)rect &#123; UIImage * img = [UIImage imageNamed:@"girl.png"]; [img drawInRect:rect]; // 拉伸填充&#125;[img drawAsPatternInRect:rect]; 平铺[img drawAtPoint:CGPointMake(20, 20)];指定绘制起点坐标 5、绘制文字1234567NSString *str = @"好学若饥，谦卑若愚";[str drawInRect:CGRectMake(10, 10, 50, 50) withAttributes:nil];//指定文字显示区域// withAttributes 这个参数可以设置一个富文本的字典// NSDictionary *dic = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:20],// NSForegroundColorAttributeName: [UIColor blueColor]&#125;;//[str drawAtPoint:CGPointMake(10, 10) withAttributes:dic];//指定起始位置显示文字 6、图形上下文栈主要作用：备份保存，相当于还原上下文初始状态，不用手动复原。 当需要连续绘制多个不同样式的图形在一起的时候，在设置当前绘图信息和绘图状态之前，保存一份图形上下文到栈区，在绘制下一个图形时，把刚才保存的那个图形上下文出栈，相当于你得到了上一个图形上下文的初始状态。 图形上下文的保存和出栈都是成对出现的。CGContextSaveGState(ctx); // 将当前图型上下文保存到一个栈里面CGContextRestoreGState(ctx); // 将图形上下文出栈 7、矩阵操作我们知道利用transform属性的旋转、平移、缩放等默认都是以中心点为基准点的。而在图形上下文中默认是以0，0点作为基准点。123456789101112CGContextRef ctx = UIGraphicsGetCurrentContext(); [[UIColor redColor] set];CGContextAddRect(ctx, CGRectMake(50, 50, 100, 100));//没缩放的红色矩形作为参照物CGContextStrokePath(ctx);[[UIColor blueColor] set];CGContextScaleCTM(ctx, 0.5, 0.5); //矩阵里的缩放// CGContextTranslateCTM(ctx, 100, 0); // 矩阵里的平移，向X坐标平移100CGContextAddRect(ctx, CGRectMake(50, 50, 100, 100));//蓝色矩形是经过矩阵操作后的矩形CGContextStrokePath(ctx); 矩阵操作里的旋转则相对难理解一点。可以通过先平移、再旋转、再上移来达到效果例如：实现旋转45度CGContextTranslateCTM(ctx, rect.size.width 0.5, rect.size.height 0.5);CGContextRotateCTM(ctx, M_PI_4);CGContextTranslateCTM(ctx, -rect.size.width 0.5, -rect.size.height 0.5); 三、绘图的三种方式1、直接图形上下文绘制1234- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextFillRect(ctx, CGRectMake(30,30, 200, 200));&#125; 2、通过创建path,每一个图形对应一个绘图路径，优点是会比较清晰，增加可读性，缺点是代码多一些1234567891011- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 拼接路径 CGMutablePathRef path1 = CGPathCreateMutable(); CGPathAddEllipseInRect(path1, NULL, CGRectMake(30,30, 200, 200)); CGContextAddPath(ctx, path1); [[UIColor redColor] set]; CGContextStrokePath(ctx); CGPathRelease(path1); // 销毁路径&#125; 3、通过UIBezierPath绘图12345- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(100, 100, 100, 200)]; [[UIColor redColor] set]; [path fill];&#125; 四、绘图应用1、在自定义View内裁剪图片（1）按照需求设定一个裁剪的封闭图形区域（2）绘制你要裁剪的图片到这个封闭区域内，超出部分会裁剪调。1234567891011121314- (void)drawRect:(CGRect)rect &#123;// 1、先画一个封闭区间的圆CGContextRef ctx = UIGraphicsGetCurrentContext();CGContextAddEllipseInRect(ctx, CGRectMake(30, 200, 200, 200));// 2、必须在渲染之前裁剪,调用该方式时要求当前上下文已经存在一个封闭的图形区域CGContextClip(ctx);// 3、渲染CGContextStrokePath(ctx);// 4、加载图片UIImage *image = [UIImage imageNamed:@"psb.jpeg"];// 设置裁剪的0，0点[image drawAtPoint:CGPointZero];&#125; 按照这个思路你可以裁剪你想要得到的图形图片。 2、脱离- (void)drawRect:(CGRect)rect 方法实现裁剪图片给UIImage做一个分类，实现常用的裁剪圆形头像的小功能12345678910111213141516171819202122232425262728293031323334353637#import "UIImage+Extension.h"@implementation UIImage (Extension)+(instancetype)circleImageWithName:(NSString *)imageName&#123; UIImage *image = [UIImage imageNamed:imageName]; UIGraphicsBeginImageContext(image.size);// 创建图形上下文 CGContextRef ctx =UIGraphicsGetCurrentContext(); CGContextAddEllipseInRect(ctx, CGRectMake(0, 0, image.size.width, image.size.height)); // 绘制圆 CGContextClip(ctx); [image drawAtPoint:CGPointZero]; // 绘制图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();// 获得图片 UIGraphicsEndPDFContext(); // 关闭图形上下文 return newImage;&#125;+(instancetype)circleImageWithName:(NSString *)imageName borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)borderColor&#123; UIImage *image = [UIImage imageNamed:imageName]; CGFloat marginX = borderWidth; CGFloat marginY = marginX; CGFloat contextW = image.size.width + marginX; CGFloat contextH = image.size.height + marginY; // 开启图形上下文 UIGraphicsBeginImageContextWithOptions(CGSizeMake(contextW, contextH), NO, 0.0); // 绘制大圆 CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextAddEllipseInRect(ctx, CGRectMake(0, 0, contextW, contextH)); [borderColor set]; CGContextFillPath(ctx); // 绘制小圆 CGContextAddEllipseInRect(ctx, CGRectMake(marginX * 0.5, marginY * 0.5, image.size.width, image.size.height)); CGContextClip(ctx); // 绘制图片 [image drawAtPoint:CGPointMake(marginX * 0.5, marginY * 0.5)]; // 从当前上下文获得图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 关闭上下文 UIGraphicsEndImageContext(); return newImage;&#125; 3、通过赋值属性改变绘制圆的大小123456789101112131415- (void)awakeFromNib &#123; [super awakeFromNib]; self.radius = 10;//设置初始圆的半径&#125;- (void)setRadius:(CGFloat)radius &#123; _radius = radius; [self setNeedsDisplay];//间接调用drawRect方法，重新绘制图画&#125;- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGFloat x = rect.size.width * 0.5; CGFloat y = rect.size.height * 0.5; CGContextAddArc(ctx,x, y, self.radius, 0, M_PI * 2, 0); CGContextFillPath(ctx);&#125; 4、简单的雪花飘落12345678910111213141516171819- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super initWithCoder:aDecoder]) &#123; CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateImage)]; link.frameInterval = 2.0; // 60 / 2 =30次 [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes]; &#125; return self;&#125;- (void)updateImage&#123; self.y += 5; [self setNeedsDisplay];&#125;- (void)drawRect:(CGRect)rect &#123; if (self.y &gt; rect.size.height) &#123; self.y = 0 ; &#125; UIImage *image = [UIImage imageNamed:@"snow"]; [image drawAtPoint:CGPointMake(10, self.y)];&#125; 5、截屏截图123456789101112// 延迟1s截屏dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 1.开启图形上下文 UIGraphicsBeginImageContext(self.view.frame.size); // 2.将控制器view的内容渲染到上下文中 [self.view.layer renderInContext:UIGraphicsGetCurrentContext()]; // 3.从图形上下文中获得图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); NSData *imageData = UIImagePNGRepresentation(newImage); [imageData writeToFile:@"/Users/apple/desktop/abc.png" atomically:YES];&#125;); 6、制作水印图1234567891011121314151617181920UIImage *image = [UIImage imageNamed:@"bgImg.png"];UIImage *logoImage = [UIImage imageNamed:@"logo.png"];CGFloat margin = 10;// 1.开启上下文UIGraphicsBeginImageContext(CGSizeMake(375, 400));// 1.1 绘制背景图[image drawInRect:CGRectMake(0, 0, 375, 400)];// 1.2 绘制logo[logoImage drawAtPoint:CGPointMake(self.view.frame.size.width - margin - logoImage.size.width, margin)]; // 1.2 绘制文字 // NSString *str = @"XX公司程序员"; // NSMutableDictionary *dict = [NSMutableDictionary dictionary]; // dict[NSFontAttributeName] = [UIFont systemFontOfSize:20]; // [str drawAtPoint:CGPointMake(151, 100) withAttributes:dict];// 2.获得图片UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();// 3.关闭上下文UIGraphicsEndImageContext();]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime]]></title>
    <url>%2F2017%2F08%2F17%2Fruntime%2F</url>
    <content type="text"><![CDATA[runtime是一套底层的C语言API（包含很多强大实用的C语言数据类型、C语言函数）运行时最主要的消息机制，是使用c语言给对象发送消息,对象接收到消息后, 找到匹配的方法执行。 常见的函数、头文件123456#import &lt;objc/runtime.h&gt; : 成员变量、类、方法Ivar * class_copyIvarList : 获得某个类内部的所有成员变量Method * class_copyMethodList : 获得某个类内部的所有方法Method class_getInstanceMethod : 获得某个实例方法Method class_getClassMethod : 获得某个类方法method_exchangeImplementations : 交换2个方法的具体实现 应用场景1：字典转模型1234567891011121314151617NSDictionary *dict =@&#123;@"name":@"普京",@"age":@18,@"score":@59&#125;;// 1、搜索类里的成员变量unsigned int count = 0;// 获取这个类所有的成员变量Ivar *Ivars = class_copyIvarList([XRPerson class], &amp;count);XRPerson *person = [[XRPerson alloc]init];for (int i = 0; i&lt;count; i++) &#123; Ivar ivar =Ivars[i]; const char *type =ivar_getTypeEncoding(ivar);//获取成员变量的类型，这里没用到 const char *name = ivar_getName(ivar);// 2、C语言转OC，去掉成员变量的下划线"_" NSMutableString *strM =[[NSMutableString alloc]initWithString:[NSString stringWithUTF8String:name]]; NSString *resultStr =[strM substringFromIndex:1];// 3、通过KVC为成员变量赋值 [person setValue:dict[resultStr] forKey:resultStr];&#125;NSLog(@"%@ %d %.2lf",person.name,person.age,person.score); 应用场景2：归档解档当你想把某个类里的所有成员变量拿出来做一些事情，或者成员变量非常多，你就可以利用运行时一次性的对这个类的所有成员变量进行归档解档。12345678910- (void)encodeWithCoder:(NSCoder *)encoder&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([XRPerson class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; Ivar ivar = ivars[i]; const char *name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; [encoder encodeObject:[self valueForKeyPath:key] forKey:key]; &#125;&#125; 应用场景3：交换2个方法的实现（Method Swizzle）每个类都维护一个方法（Method）列表，Method则包含SEL和其对应IMP的信息，方法交换做的事情就是把SEL和IMP的对应关系断开，并和新的IMP生成对应关系。method_exchangeImplementations 交换2个方法的中的实现class_replaceMethod 修改类method_setImplementation 直接设置某个方法的实现class_getInstanceMethod 获取通过SEL获取一个方法method_getTypeEncoding 获取一个OC实现的编码类型class_addMethod 給方法添加实现 1、当你想对系统的方法做一些手脚，添加或者修改些什么的时候，就可以用runtime交换2方法的实现 2、旧项目用的是imageNamed方法通过简单判断来适配图片的，图片多了，重复代码很垃圾，难更改，难维护。解决方案：利用运行时交换两个方法的实现。写一个image分类，用分类写的方法与系统的方法实现交换了。123456789101112131415161718192021#import &lt;objc/runtime.h&gt;@implementation UIImage (Extension)+(void)load&#123; // 只要分类被装载到内存中，就会调用1次 Method originMethod = class_getClassMethod(self, @selector(imageNamed:)); Method otherMethod = class_getClassMethod(self, @selector(imageWithName:));// 交换2个方法的实现 method_exchangeImplementations(originMethod, otherMethod);&#125;+(UIImage *)imageWithName:(NSString *)name&#123; BOOL iOS8 = [[UIDevice currentDevice].systemVersion floatValue]&gt;=8.0; UIImage *image =nil; if (iOS8) &#123; NSString *newName=[name stringByAppendingString:@"_os8"]; image=[UIImage imageWithName:newName]; &#125; if (image==nil) &#123; image =[UIImage imageWithName:name]; &#125; return image;&#125; 4、屏蔽数组传nil报错,数组越界报错（负面效果是难找到报错，谨慎实用，看场合，权衡使用）解决方案：利用运行时的交换方法的实现的办法（1）只要外面传nil，我在内部就不管它，（2）或者自己打印出来哪里传了nil，这样我们就能发现错在哪，要不然找不到报错的地方。（3）还可以在里面做一些自己想做的事，过滤一些东西，比如：只有传的是string类型的，我才添加到数组中。 5、屏蔽字典传空错误 注意：多个有继承关系的类对象swizzle时，先从父对象开始，这样才能保证子类方法拿到父类中的被swizzle的实现。在+（viod）load中swizzle不会出错，就是因为load类方法会默认从父类开始调用。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView动画]]></title>
    <url>%2F2017%2F08%2F17%2FUIView%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[UIView动画实质上是对Core Animation的封装，提供简洁的动画接口。对于简单的应用场景，使用UIView动画非常方便简洁。 一、基础动画12345678[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 delay:(NSTimeInterval) //动画延迟执行的时间 options:(UIViewAnimationOptions) //动画的过渡效果 animations:^&#123; //执行的动画 &#125; completion:^(BOOL finished) &#123; //动画执行完毕后的操作 &#125;]; UIViewAnimationOptions的枚举值如下，可组合使用：123456789101112131415161718192021222324UIViewAnimationOptionLayoutSubviews //进行动画时布局子控件 UIViewAnimationOptionAllowUserInteraction //进行动画时允许用户交互 UIViewAnimationOptionBeginFromCurrentState //从当前状态开始动画 UIViewAnimationOptionRepeat //无限重复执行动画 UIViewAnimationOptionAutoreverse //执行动画回路 UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置 UIViewAnimationOptionOverrideInheritedCurve //忽略嵌套动画的曲线设置 UIViewAnimationOptionAllowAnimatedContent //转场：进行动画时重绘视图 UIViewAnimationOptionShowHideTransitionViews //转场：移除（添加和移除图层的）动画效果 UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置 UIViewAnimationOptionCurveEaseInOut //时间曲线，慢进慢出（默认值） UIViewAnimationOptionCurveEaseIn //时间曲线，慢进 UIViewAnimationOptionCurveEaseOut //时间曲线，慢出 UIViewAnimationOptionCurveLinear //时间曲线，匀速 UIViewAnimationOptionTransitionNone //转场，不使用动画 UIViewAnimationOptionTransitionFlipFromLeft //转场，从左向右旋转翻页 UIViewAnimationOptionTransitionFlipFromRight //转场，从右向左旋转翻页 UIViewAnimationOptionTransitionCurlUp //转场，下往上卷曲翻页 UIViewAnimationOptionTransitionCurlDown //转场，从上往下卷曲翻页 UIViewAnimationOptionTransitionCrossDissolve //转场，交叉消失和出现 UIViewAnimationOptionTransitionFlipFromTop //转场，从上向下旋转翻页 UIViewAnimationOptionTransitionFlipFromBottom //转场，从下向上旋转翻页 二、Spring动画1234567891011[UIView animateWithDuration:(NSTimeInterval) delay:(NSTimeInterval) usingSpringWithDamping:(CGFloat)//震动效果，范围0~1，数值越小震动效果越明显 initialSpringVelocity:(CGFloat)//初始速度，数值越大初始速度越快 options:(UIViewAnimationOptions) animations:^&#123; &#125; completion:^(BOOL finished) &#123; &#125;]; 三、Keyframes动画只支持属性关键帧，不支持路径关键帧123456789[UIView animateKeyframesWithDuration:(NSTimeInterval) delay:(NSTimeInterval) options:(UIViewKeyframeAnimationOptions) animations:^&#123; //执行的关键帧动画 &#125; completion:^(BOOL finished) &#123; &#125;]; 增加关键帧的方法：12345[UIView addKeyframeWithRelativeStartTime:(double)//动画开始的时间（占总时间的比例） relativeDuration:(double) //动画持续时间（占总时间的比例） animations:^&#123; //执行的动画 &#125;]; UIViewKeyframeAnimationOptions的枚举值如下，可组合使用：12345678910111213UIViewAnimationOptionLayoutSubviews //进行动画时布局子控件UIViewAnimationOptionAllowUserInteraction //进行动画时允许用户交互UIViewAnimationOptionBeginFromCurrentState //从当前状态开始动画UIViewAnimationOptionRepeat //无限重复执行动画UIViewAnimationOptionAutoreverse //执行动画回路UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置UIViewKeyframeAnimationOptionCalculationModeLinear //运算模式 :连续UIViewKeyframeAnimationOptionCalculationModeDiscrete //运算模式 :离散UIViewKeyframeAnimationOptionCalculationModePaced //运算模式 :均匀执行UIViewKeyframeAnimationOptionCalculationModeCubic //运算模式 :平滑UIViewKeyframeAnimationOptionCalculationModeCubicPaced //运算模式 :平滑均匀 四、转场动画1、单个视图的过渡效果123456789[UIView transitionWithView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) animations:^&#123; &#125; completion:^(BOOL finished) &#123; &#125;]; 2、从旧视图转场到新视图的动画效果1234567[UIView transitionFromView:(nonnull UIView *) toView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) completion:^(BOOL finished) &#123; &#125;]; // toView added to fromView.superview, fromView removed from its superview 五、UIImageView设置图片帧动画123456789// _afterWheel 是一个UIImageViewNSMutableArray* after = [NSMutableArray array];for(int i = 1;i&lt;4;i++)&#123; [after addObject: [UIImage imageNamed:[NSString stringWithFormat:@"resource.bundle/%@%d",@"porche-f",i]]];&#125;_afterWheel.animationImages = after;_afterWheel.animationDuration = 0.05;_afterWheel.animationRepeatCount = 0;[_afterWheel startAnimating];]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer]]></title>
    <url>%2F2017%2F08%2F16%2FCALayer%2F</url>
    <content type="text"><![CDATA[如果一个layer是被一个view创建的,那么这个view通常会自动被赋值给这个layer的delegate属性(也就算说这个view就是这个layer的代理)。你不应该改变这种关系。对于你自己创建的layer,你可以赋值一个代理对象用来动态提供layer的内容和执行其他的任务。 如果一个layer已经关联了一个view对象。那么layer的delegate属性必须设置为这个拥有这个layer的view本身。 UIView和CALayer的关系UIView是iOS页面控件的基类，因为UIView直接继承自UIResponder，所以可以响应用户事件，在iOS中创建的每一个UIView都有一个属性layer（CALayer），layer继承自己NSObject，不能响应用户事件，但layer提供了UIView内容的绘制功能，也就是说UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。UIView和CALayer相互依赖，UIView依赖于CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容，UIView可以理解为是CALayer的高级封装。 一、基础使用1234567891011121314151617// 边框颜色self.iconView.layer.borderColor = [UIColor orangeColor].CGColor;// 边框宽度self.iconView.layer.borderWidth = 10;// 圆角半径self.iconView.layer.cornerRadius = 10;// 超出图层边框的内容裁剪掉self.iconView.layer.masksToBounds = YES;// 颜色self.iconView.layer.shadowColor = [UIColor blackColor].CGColor;// 偏移量self.iconView.layer.shadowOffset = CGSizeMake(10, 10);// 透明度self.iconView.layer.shadowOpacity = 0.5;// 内容self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 示例：实现UIImageView既能设置圆角,也能设置阴影? 思路：创建两个图层，一个负责圆角,一个负责阴影123456789101112131415161718// 创建背景图层用来设置阴影CALayer *bgLayer = [CALayer layer];bgLayer.frame = CGRectMake(100, 100, 100, 100);bgLayer.backgroundColor = [UIColor clearColor].CGColor;// 设置阴影bgLayer.shadowColor = [UIColor purpleColor].CGColor;bgLayer.shadowOffset = CGSizeMake(10, 10);bgLayer.shadowOpacity = 0.5;// 创建子图层负责显示图片和设置圆角CALayer *subLayer = [CALayer layer];subLayer.frame = bgLayer.bounds;subLayer.cornerRadius = 20;subLayer.masksToBounds = YES;subLayer.contents = (id) [UIImage imageNamed:@"girl.png"].CGImage;[bgLayer addSublayer:subLayer];[self.view.layer addSublayer:bgLayer]; 二、CALayer的transform属性1234567891011121314// 平移self.iconView.layer.transform = CATransform3DMakeTranslation(100, 100, 13210); //缩放self.iconView.layer.transform = CATransform3DMakeScale(0.5, 1, 100);// 旋转self.iconView.layer.transform = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);self.iconView.transform = CGAffineTransformMakeRotation(M_PI_4);// 旋转 100弧度[self.iconView.layer setValue:@(100) forKeyPath:@"transform.rotation.z"];// 全局缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale"];// 指定X轴方向缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale.x"]; 注意：CALayer 还有一个锚点属性.anchorPoint，锚点默认是在图层的中心位置，如果改变锚点，会对图层position属性造成影响。 三、CALayer的隐式动画1234567891011//直接修改layer的大小、位置等一些属性会默认执行动画(subLayer为自定义创建的layer,添加在self.view.layer上)self.subLayer.position = CGPointMake(200, 200);self.subLayer.bounds = CGRectMake(0, 0, 250, 250);// 开启事务[CATransaction begin];// 禁止执行隐式动画[CATransaction setDisableActions:YES];self.subLayer.position = CGPointMake(200, 200);// 提交事务[CATransaction commit]; 我们自己写的动画都属于显式动画，当定义显示动画后，相应的隐式动画会自动取消。 四、CALayer可以动画的属性由于CALayer在iOS中任务主要是内容展示和动画操作，并且动画操作是CALayer的一个重要功能，因此CALayer很多属性的值在变化的时都有动画效果，这个就是我们之前提到的“隐式动画”（手动创建的CALayer对象，都存在着隐式动画），但UIView的根图层是一个例外，根图层属性修改的时候不形成动画效果，因为根图层充当容器的作用，如果它的属性变化形成动画效果会直接干扰子图层。另外，根图层是是由UIView管理，不能重新创建。 常用的图层属性请参照苹果开发文档中的CALayer Animatable Properties 注意：CALayer使用bounds和position属性，position在子图层的位置由anchorPoint决定，frame属性很少使用 CALayer透明度使用opacity，而不是alpha 五、CALayer的内容绘制1、使用图片为图层提供内容（适用于图层内容几乎不改变的情况）1self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 2、使用代理提供图层内容如果图层内容是动态改变的，则可以使用代理对象在需要的时候提供图层并更新内容。图层显示的时候，从代理方法获取内容，代理方法主要有以下两个： - (void)displayLayer:(CALayer *)layer; - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 如果实现了displayLayer:方法，实现方法负责创建位图并赋值给contents属性如果实现了drawLayer: inContext:方法，Core Animation创建一个位图，创业一个用于绘制位图的上下文，并调用代理方法填充该位图，代理方法所需要做的是将内容画在图形上下文中。注意：代理对象必须实现以上两个方法之一，如果代理对象把以上两个法都实现了，那么图层需要内容的时候，只调用displayLayer:代理方法。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Animation]]></title>
    <url>%2F2017%2F08%2F16%2FCore-Animation%2F</url>
    <content type="text"><![CDATA[CoreAnimation是iOS与OS X平台上负责图形渲染与动画的基础设施。Core Animation可以动画视图和其他的可视元素，为你完成了动画所需的大部分绘帧工作。只需配置少量的动画参数（如开始点位置和结束点的位置）就可实现绚丽的Core Animation动画效果。 Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且更加的平滑，而且不会加重CPU的负担而影响程序的运行速度。 Core Animation自身并不是一个绘图系统。它只是一个负责在硬件上合成和操纵应用内容的基础构件。Core Animation的核心是图层对象，图层对象用于管理和操控你的应用内容。图层将捕获的内容放到一副位图中，图形硬件能够非常容易的操控你的位图。 当我们平时使用UIView动画不能满足需求的时候，可以直接对UIView的内容绘制的layer进行操作，Core Animation是UIview动画底层的实现，是对CALayer进行操作，所以Core Animation操作的对象是CALayer，而不是UIView。 Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程(执行动画的时候还能点击UI其它控件触发别的事件）。 CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用 CABasicAnimation：基本动画，通过属性修改进行动画参数控制，只有初始状态和结束状态CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行CATransition：转场动画，主要通过滤镜进行动画效果设置 一、CABasicAnimation1234567891011121314151617181920212223CABasicAnimation *anim = [CABasicAnimation animation];// 通过keyPath来告诉layer要执行怎样的动画(旋转,平移,缩放)，该属性必须是layer的一个属性anim.keyPath = @"transform.scale.x";// anim.keyPath = @"transform.rotation.z";// anim.keyPath = @"position"; // anim.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 200)];// anim.keyPath = @"bounds"; // anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 250, 250)];// anim.keyPath = @"transform"; // anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_4, 0, 0, 1)];anim.fromValue = @(4);anim.toValue = @(1.5);// 还可以设置成颜色变化// anim.toValue = (id)[UIColor redColor].CGColor;// 动画结束后不要移除动画效果anim.removedOnCompletion = NO;// 保持动画执行后的状态anim.fillMode = kCAFillModeBoth;// 设置动画的执行时间 （当前动画时间 + 延迟2s执行）anim.beginTime = CACurrentMediaTime() + 2;[self.blueView.layer addAnimation:anim forKey:nil]; 二、CAKeyframeAnimation 1、做一个抖动效果123456789// 角度转换弧度的宏#define angle2Radian(angel) ((angel) * M_PI / 180.0)CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"];anim.values = @[@(angle2Radian(-3)),@(angle2Radian(3)),@(angle2Radian(-3))];anim.repeatCount = MAXFLOAT;anim.duration = 0.2f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;[self.redView.layer addAnimation:anim forKey:@"abc"]; 2、设置关键帧数组values 12345678910111213141516 CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 设置关键帧anim.values = @[[NSValue valueWithCGPoint:CGPointZero], [NSValue valueWithCGPoint:CGPointMake(200, 0)], [NSValue valueWithCGPoint:CGPointMake(200, 200)], [NSValue valueWithCGPoint:CGPointMake(0, 200)], [NSValue valueWithCGPoint:CGPointZero]];// 设置关键帧执行的时间点(每一个元素的取值范围是0到1,后面的值要大于前面的值)anim.keyTimes = @[@(0),@(0.1),@(0.5),@(0.8),@(1)];anim.duration = 2.0f;// 保持动画执行完毕的状态anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;// 设置动画执行节奏anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];[self.redView.layer addAnimation:anim forKey:nil]; 3、设置路径path12345678910CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建一个圆圈路径CGMutablePathRef path = CGPathCreateMutable();CGPathAddEllipseInRect(path, NULL, CGRectMake(100, 100, 250,250));anim.path = path;anim.duration = 2.0f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[self.redView.layer addAnimation:anim forKey:nil]; 三、CAAnimationGroup12345678910111213141516171819202122232425262728293031323334353637383940CAKeyframeAnimation *position = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建路径CGMutablePathRef path = CGPathCreateMutable();// 起始CGPathMoveToPoint(path, NULL, startPoint.x, startPoint.y);// 创建关键控制点数组（数组存放CGRect, CGRect的x、y值作为控制点xy坐标值，width和height作为结束点的xy坐标值） NSMutableArray *pointArrs = [[NSMutableArray alloc] init]; CGFloat width = [UIScreen mainScreen].bounds.size.width / 2; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))]; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))];[pointArrs enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CGRect rect = CGRectFromString(obj); // 二阶贝塞尔曲线 CGPathAddQuadCurveToPoint(path, NULL, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);&#125;];// 结束CGPathAddQuadCurveToPoint(path, NULL, endPoint.x, endPoint.y, endPoint.x, endPoint.y);position.path = path;position.duration = 5.0;position.speed = 0.7;position.removedOnCompletion = NO;position.fillMode = kCAFillModeForwards;CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];scaleAnimation.duration = 1.2;scaleAnimation.beginTime = 0.f;scaleAnimation.fromValue = [NSNumber numberWithFloat:0.7];scaleAnimation.toValue = [NSNumber numberWithFloat:1.5];scaleAnimation.removedOnCompletion = _removedOnCompletion;scaleAnimation.fillMode = kCAFillModeForwards;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];animationGroup.duration = 5+3;animationGroup.removedOnCompletion = NO;animationGroup.fillMode = kCAFillModeForwards;animationGroup.delegate = self;animationGroup.animations = @[position,scaleAnimation];[self.layer addAnimation:animationGroup forKey:@"SpecialGiftCar"]; 四、CATransition12345678910// 1.创建动画对象CATransition *tran = [CATransition animation];// 2.设置转场效果tran.type = @"oglFlip";// 3.设置转场方向tran.subtype = kCATransitionFromRight;NSString *imagename = [NSString stringWithFormat:@"%d",self.index];self.imageView.image = [UIImage imageNamed:imagename];// 4.添加动画到图层上[self.imageView.layer addAnimation:tran forKey:nil]; 附：过渡效果fade //交叉淡化过渡(不支持过渡方向) kCATransitionFadepush //新视图把旧视图推出去 kCATransitionPushmoveIn //新视图移到旧视图上面 kCATransitionMoveInreveal //将旧视图移开,显示下面的新视图 kCATransitionReveal /**下面几个也是过渡效果，但它们是私有API效果，使用的时候要小心，可能会导致app审核不被通过*/cube //立方体翻滚效果oglFlip //上下左右翻转效果suckEffect //收缩效果，如一块布被抽走(不支持过渡方向)rippleEffect //滴水效果(不支持过渡方向)pageCurl //向上翻页效果pageUnCurl //向下翻页效果cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向)cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell实现多选、全选、全不选]]></title>
    <url>%2F2017%2F08%2F07%2FUITableViewCell%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%80%89%E3%80%81%E5%85%A8%E9%80%89%E3%80%81%E5%85%A8%E4%B8%8D%E9%80%89%2F</url>
    <content type="text"><![CDATA[使用场景之一：购物车的时候用到1、设置cell可多选属性1self.tableV.allowsMultipleSelection = YES; 2、设置cell选择状态1cell.selectionStyle = UITableViewCellSelectionStyleNone 3、在cell上自定义一个选择Button(自定义名为：checkBtn)，Button的selected属性跟cell里的selected的属性绑定。设置Button的两种状态：UIControlStateNormal和UIControlStateSelected的不同状态图片。1234- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; self.checkBtn.selected = selected;&#125; 4、获取所有被选中的cell的NSIndexPath数组1NSArray * selectRows = self.tableV.indexPathsForSelectedRows; 5、全选/取消全选1234567891011if (select) &#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone]; &#125; &#125;else&#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV deselectRowAtIndexPath:indexPath animated:YES]; &#125; &#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天周末，兴致所致，有点强迫症的我还是想做一个素雅无任何广告的博客，用来记录一点生活和学习相关的东西，便有了此博客的诞生。 这是使用Github Pages + Hexo 搭建的博客。 在此感谢 Github , 感谢 Hexo , 感谢 Line 的博客搭建教学。 基础命令1、如何创建博客文章？ 1$ hexo new "搭建博客" 更多指令信息可查看文档: Writing 2、 清理缓存 1$ hexo clean 网页正常情况下可以忽略此条命令 3、 生成静态网页 1$ hexo generate 默认生成的静态网页放在public目录博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作只要输入hexo generate命令即可，hexo会帮我们完成转换。Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 语法说明 4、 开启预览访问端口 1$ hexo server 默认端口4000，’ctrl + c’关闭server 5、 将.deploy目录部署到GitHub 1$ hexo deploy 文档编辑1、写标题12### 一、我是标题#### 1、我也是标题 2、插入图片（图片可以托管在七牛上，也可以放在hexo的资源文件夹里）1![Image text](http://ouakkqmoq.bkt.clouddn.com/coreAnimation.png) 3、不完全显示文章内容，在适当位置添加“查看全部”按钮1&lt;!--more--&gt; 4、写代码123``` bash这里是代码内容(```)只有三个点，没有这个括号]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
