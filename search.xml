<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS私有库实现方案]]></title>
    <url>%2F2018%2F02%2F07%2FiOS%E7%A7%81%E6%9C%89%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[iOS项目组件化架构方案中，需要把每个组件以独立工程的形式存储在远程仓库 远程私有库实现创建远程索引库1、在第三方代码托管网站coding创建私有的远程索引仓库，命名为PjPodspecs2、使用终端命令生成ssh对称密码对1ssh-keygen 在/Users/xianrong/.ssh 路径可以查看到id_rsa和id_rsa.pub这两个文件，它们分别为私钥和公钥3、使用公钥在coding网站上的(账户 –&gt; SSH公钥)上进行设置。4、把远程索引库拉取到本地，取名为“ProjectPodspecs”1pod repo add ProjectPodspecs git@git.coding.net:Captain-XR/PjPodspecs.git 可在/Users/xianrong/.cocoapods/repos/路径下查看到ProjectPodspecs，也可以使用终端命令pod repo查看 创建远程代码库，并提交代码1、在第三方代码托管网站coding创建私有远程仓库，命名为PjBase2、克隆pod模板库在自定义的/Users/xianrong/Desktop/Component/路径下1pod lib create ProjectBase 3、把要上传的代码拷贝到ProjectBase/ProjectBase/Classes/路径下，并把ReplaceMe文件删除。4、进入ProjectBase/Example/路径下进行安装1pod install 5、把本地代码提交到远程代码库PrivateLib在/Users/xianrong/Desktop/Component/ProjectBase/路径下12git add .git commit -m "初始化基础组件" 修改ProjectBase.podspec文件内容1234567s.summary = 'ProjectBase.'s.description = &lt;&lt;-DESCProjectBase.包含了基本的配置，分类，宏文件，工具类等等 DESCs.homepage = 'https://coding.net/u/Captain-XR/p/PjBase's.source = &#123; :git =&gt; 'https://git.coding.net/Captain-XR/PjBase.git', :tag =&gt; s.version.to_s &#125;s.dependency 'AFNetworking' #依赖库 提交更改12git add .git commit -m "配置spec文件" 对刚才修改的spec进行本地验证（非必须）：1pod lib lint 添加远程仓库地址1234git remote #查看有无origingit remote -v #查看现有远程仓库的地址git remote rm origin #移除git remote add origin git@git.coding.net:Captain-XR/PjBase.git #添加远程仓库，url或ssh 提交代码到远程1git push origin master 小插曲：push提交失败使用了强制提交命令git push -u origin master -f这样会使远程修改丢失，慎用！ 本地打标签12git tag '0.1.0'# git tag -d 0.1.0 #移除本地标签 远程打标签12git push --tags# git push origin :0.1.0 #移除远程标签 远程验证1pod spec lint 本地spec提交到远程私有spec仓库进入/Users/xianrong/Desktop/Component/ProjectBase/路径下1pod repo push ProjectPodspecs ProjectBase.podspec 这时本地.cocoapods子路径下和远程仓库PjPodspecs都能看到了ProjectBase.podspec了这个提交过程其实是：把本地代码里的spec提交到本地私有spec库（即/Users/xianrong/.cocoapods/repos/ProjectPodspecs），它会自动将本地私有spec库提交到关联的远程spec库 把创建好的远程私有库引入宿主工程查看源1pod repo 在Podfile文件里添加源，举例：12345678910source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;git@git.coding.net:Captain-XR/PjPodspecs.git&apos; platform :ios, &apos;9.0&apos; use_frameworks!target &apos;mainProj&apos; do pod &apos;ProjectBase&apos; pod &apos;MJExtension&apos;end 远程私有库升级版本1、在ProjectBase/ProjectBase/Classes/路径下添加新代码2、修改ProjectBase.podspec文件内容1s.version = '0.2.0' 3、进入ProjectBase/Example/路径下进行安装1pod install 4、把本地代码提交到远程代码库PrivateLib在/Users/xianrong/Desktop/Component/ProjectBase/路径下12git add .git commit -m "新增0.2.0版本,XXX功能" 1235、对刚才修改的spec进行本地验证``` bashpod lib lint 如果创建的是swift项目，提示.swift-version报错，执行1echo "3.2" &gt; .swift-version 6、提交代码到远程1git push origin master 本地打标签1git tag '0.1.0' 远程打标签1git push --tags 远程验证1pod spec lint 7、本地spec提交到远程私有spec仓库进入/Users/xianrong/Desktop/Component/ProjectBase/路径下1pod repo push ProjectPodspecs ProjectBase.podspec 远程私有库划分子库举例：把基础组件ProjectBase划分为Category、Network、Macro、Tool四个子库1、修改ProjectBase.podspec文件内容把source_files和dependency部分进行进行修改1234567891011121314151617181920# s.source_files = 'ProjectBase/Classes/**/*'# s.dependency 'AFNetworking', '~&gt; 2.3's.subspec 'Category' do |a| a.source_files = 'ProjectBase/Classes/Category/**/*'ends.subspec 'Network' do |b| b.source_files = 'ProjectBase/Classes/Network/**/*' b.dependency 'AFNetworking'ends.subspec 'Macro' do |c| c.source_files = 'ProjectBase/Classes/Macro/**/*'ends.subspec 'Tool' do |d| d.source_files = 'ProjectBase/Classes/Tool/**/*'end# 上面的a、b、c、d是自定义的别名 dependency部分可以根据具体情况进行设置，上面例子因为只有Network子库依赖用到AFNetworking，因此把依赖写进对应子库内部。2、参照“远程私有库升级版本”步骤操作进行升级版本。3、在引用项目Podfile文件里引用子库12pod 'ProjectBase/Category'pod 'ProjectBase/Network' 或者1pod 'ProjectBase', :subspecs =&gt; ['Category','Network'] 创建多个组件库克隆pod模板库在自定义的/Users/xianrong/Desktop/Component/路径下1pod lib create ProjectMain 在处理ProjectMain组件的Example（测试用例工程）时，注意点：举例：ProjectMain组件依赖ProjectBase组件中的Category子库1、在Example的Podfile文件里添加ProjectBase组件源和pod官方源12source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;git@git.coding.net:Captain-XR/PjPodspecs.git&apos; 2、修改ProjectMain.podspec文件内容1s.dependency 'ProjectBase/Category' 3、Example里如果涉及到加载bundle资源的问题mainBundle是指测试项目的bundle，应该是调整为从组件的framework对应的bundle里找对应的资源12// NSBundle * mainBundle = [NSBundle mainBundle];NSBundle *currentBundle = [NSBundle bundleForClass:[self class]]; 4、组件内的资源图片放置在/…/ProjectMain/ProjectMain/Assets/路径下打开ProjectMain.podspec文件里的图片引用路径123s.resource_bundles = &#123; 'ProjectMain' =&gt; ['ProjectMain/Assets/*']&#125; 5、属于组件内部的xib中图片的路径需要调整为组件framework内部的资源文件路径ProjectMain.bundle/btn_imgName6、属于组件内部的图片加载方式需要调整（不属于组件内部的图片则放在测试工程里可以使用imageNamed:的方式）1234// UIImage * img = [UIImage imageNamed:@"tabbar_home"]; //这种方式加载不到图片，imageNamed：是从测试工程获取NSBundle *currentBundle = [NSBundle bundleForClass:[self class]];NSString *imagePath = [currentBundle pathForResource:@"tabbar_home@2x.png" ofType:nil inDirectory:@"ProjectMain.bundle"];UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; 本地私有库实现1、进入ProjectTest文件夹目录1234git initgit add .git commit -m "初始化本地私有库"pod spec create ProjectTest 2、把代码文件添加到ProjectTest/Classes/路径下3、修改.podspec文件内容：123s.description = "分类、工具类等"s.license = "MIT"s.source = &#123; :git =&gt; "", :tag =&gt; "#&#123;s.version&#125;" &#125; 4、在项目的Podfile文件中添加路径：1pod 'ProjectBase', :path =&gt;'/Users/xianrong/Desktop/Component/ProjectTest' 注意：该路径为找得到.podspec的本地路径1pod install 附上.podspec文件内容含义：s.name：名称，pod search 搜索的关键词s.version：版本号s.ios.deployment_target:支持的pod最低版本s.summary: 简介s.homepage:项目主页地址s.license:许可证，例如s.license= { :type =&gt; “MIT”, :file =&gt; “LICENSE” }s.author:作者s.social_media_url:社交网址,这里我写的微博默认是Twitter,如果你写Twitter的话,你的podspec发布成功后会@你s.source:项目的地址s.source_files:需要包含的源文件，s.resources: 资源文件s.requires_arc: 是否支持ARCs.dependency：依赖库，不能依赖未发布的库s.dependency：依赖库，如有多个可以这样写s.dependency = ‘AFNetworking’ source_files:写法及含义123"Classes/*""Classes/**/*.&#123;h,m&#125;""Classes/**/*.h" ““ 表示匹配所有文件“.{h,m}” 表示匹配所有以.h和.m结尾的文件“**” 表示匹配所有子目录 组件私有库自动化升级思路方案：使用fastlane实现自动化带包发布安装fastlane1sudo gem install fastlane --verbose 进入工程路径，初始化fastlane1fastlane init 更多了解：fastlanedocs 我们可以利用fastlane自定义做组件私有库升级的一些步骤实现自动化:123456789# 1、pod install# 2、git add .# 3、git commit -m 'xxx'# 4、git push origin master# 5、验证tag是否已存在，如果存在，应该删除本地标签和远程标签# 6、git tag 标签名称# 7、git push --tags# 8、pod spec lint# 9、pod repo push XXXX AAA.podspec]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS项目组件化开发]]></title>
    <url>%2F2018%2F01%2F30%2FiOS%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[组件化概述随着项目Swift化、跨平台混合开发、业务越来越复杂等的因素，不管是老项目重构还是新项目开发，都需要引入组件化架构开发方案。组件化开发方案在业务类型多、开发团队大、多APP多功能有交叉、多语言混编的项目所体现出来的优势尤为明显。组件化的思想其实就是解决模块业务之间的强依赖，引入一个中间层（中间人）进行解耦，让中间层进行统一调度。（强依赖：模块A调用模块B的服务，不需要在A模块中import B）每个组件使用pod远程私有库以独立工程的形式存在。难点：解决组件之前的交互通信；基于不同业务进行的项目架构组件划分；需要处理的细节多。组件间的通信是有成本的，尽量将业务封装在组件内部，对外统一提供简单的接口，即“高内聚，低耦合”原则。 组件化开发带来的好处：1、业务划分更清晰，接受容易，可按组件分配开发任务；2、开发测试过程中，可以只编译某组件部分代码，不需要编译整个项目代码；3、排查问题容易，某个组件出现问题，直接对组件进行处理；4、集成方便，像搭积木一样组装。项目维护性强。 混编模块化划分不应该从业务拆分，而是从底层抽离，例如 Extension、工具类等 中间件设计方案参考1、URL-Block方案参考蘑菇街的组件化方案MGJRouter的url-block好处：参数类型无数量限定，传递灵活，返回值类型无限定问题：产生很多硬编码的URL和参数不过蘑菇街也提供了补充方案：（1）开发了web页面统一来管理所有的URL和参数。（2）提供了Protocol方案做补充，将所有涉及到硬编码的都放在组件的PublicHeader.h中。（Protocol方案调用和维护较麻烦一些）。 2、Target-Action方案参考Casa Taloyum的iOS应用架构谈 组件化方案 3、协议方案参考Lotusoot 组件统一披露API1、需要提供哪些服务给外界2、外界需要给我提供哪些服务（让外界以block的形式，或者通知的形式传递数据到组件内部，内部做相应处理）]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Swift构建服务端]]></title>
    <url>%2F2018%2F01%2F26%2F%E4%BD%BF%E7%94%A8Swift%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[使用Swift后端开源框架Perfect，需要最新版本的Swift 4.0 创建Swift软件包1、创建名为myServer的项目文件夹12mkdir myServercd myServer 2、初始化项目1swift package init --type=executable 3、打开Package.swift文件进行编辑(要求Swift编译的最低版本为3.0.0)1234567891011let package = Package( name: "myServer", dependencies: [ .package(url: "https://github.com/PerfectlySoft/Perfect-HTTPServer.git", from: "3.0.0") ], targets: [ .target( name: "myServer", dependencies: ["PerfectHTTPServer"]), ]) 4、编译和运行12swift build.build/debug/myServer 设置服务器1、在main.swift文件编写12345678910111213141516import PerfectHTTPimport PerfectHTTPServer//注册路由和请求/响应句柄var routes = Routes()routes.add(method:.get,uri:"/")&#123;request,response in response.setHeader(.contentType, value: "text/html") response.appendBody(string: "&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;") .completed()&#125;do&#123; // 启动HTTP服务器 try HTTPServer.launch(.server(name:"www.example.ca",port:8181,routes:routes))&#125;catch&#123; fatalError("\(error)")&#125; 2、再次编译运行可看到[INFO] Starting HTTP server www.example.ca on :::8181,此时服务器已启动运行，浏览器访问http://localhost:8181/就可以看到欢迎信息了。control+c可停止服务器。3、利用Swift软件包管理器（SPM）为项目生产Xcode工程，方便运行和调试1swift package generate-xcodeproj 4、打开工程，在”Library Search Paths“检索项目软件库中增加：1$(PROJECT_DIR) - Recursive 5、请选择 “My Mac”，选择”myServer”。现在您就可以在Xcode中运行调试您的服务器了。 补充编译debug版本的使用：swift build，可执行文件被放在.build/debug/隐藏目录下；编译release版本的使用：swift build -c release,可执行文件被放到.build/release/路径下；清理编译临时文件，删除.build，使用：swift build –clean清理.build目录和Packages目录，使用：swift build –clean=dist]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习]]></title>
    <url>%2F2018%2F01%2F18%2FReactNative%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React Native是Facebook于2015年9月15日发布的框架。该框架可以使用JavaScript和React开发跨平台移动应用。RN是面向组件开发。React Native特点：1）使用 Virtual DOM（虚拟DOM，存在于内存之中的一种数据结构，可以极大提高网页的性能）2）提供了响应式（Reactive）和组件化（Composable）的视图组件；3）将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。React Native的优势：1）跨平台开发：使用同一份业务逻辑核心代码来创建原生应用运行在Web端，Android端和iOS端；2）追求极致的用户体验：实时热部署3）learn once,write everywhere目前react native在iOS上仅支持ios7以上，Android仅支持Android4.1以上版本；开发者可以灵活的使用HTML和CSS布局,使用React语法构建组件,实现：Android, iOS 两端代码的复用。常用组件：View、Text、Image、TextInput、Touchable系列、ScrollView、RefreshControl、ListView、TabBarIOS、TabBarIOS.Item、Navigator、NavigatorIOS布局方式：FlexBox布局组件生命周期：实例化阶段、存在阶段、销毁阶段网络请求：Ajax、fetchReact的一大创新是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染UI。例如当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。这种创新机制得益于DOM Diff算法。 提升方式：实战练习，看github上比较高质量的开源源码，融入开发项目中。 参考学习资料：github地址官网文档ReactRN中文网特定功能的第三方库RN中文学习资源React Native PlaygroundFacebook的F8开发大会有一个对应的app源码及 教程中文论坛组件分享区中文论坛问题求助区Pushy热更新服务]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBuilder项目本地打包及混合开发]]></title>
    <url>%2F2018%2F01%2F15%2FHBuilder%E9%A1%B9%E7%9B%AE%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85%E5%8F%8A%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近接触了一个DCloud（数字天堂）平台的HBuilder（IDE）编写的移动APP项目，该平台提供了MUI、5+Runtime、Native.js做支持快发，再通过云打包和本地打包两种方式，实现一套代码打包成为两端（iOS和安卓）的APP。MUI：前端UI框架5+Runtime：增强版的手机浏览器引擎Native.js：封装一条通过JS语法直接调用Native接口通道，通过plus.ios可调用几乎所有的系统API。HBuilder的云端打包可以很方便的打包出两端的包（不能超过40M），此处不再累赘。 项目需求：改造一个基于HBuider开发的移动APP项目，把其中一个直播页面使用iOS原生控制器，加载腾讯云SDK拉流实现直播画面。目的：在不大量改动原项目基础上，提高直播页用户体验。方案一：整个直播页面上视频层和交互控件都使用原生控件,使用js与原生之间的交互。方案二：使用原生控制器加载视频层放于最底下，上面交互控件直接使用webView加载一个透明背景的H5页面。这样业务逻辑处理更多使用原始项目的js本身。该项目涉及到的有本地打包、H5前端与iOS原生交互的两个部分。 本地打包参考官方文档HTML5+SDK下载HTML5+的SDK对照Feature-iOS.xls文件按需导入对应的系统库(framework)、静态库(.a)、资源包（.bundle）导入inc文件夹和control.xml文件以资源文件的方式导入HBuilder项目 混合交互iOS原生加载html5入口页面12345678PDRCore* pCoreHandle = [PDRCore Instance];pCoreHandle.coreDeleagete = self;pCoreHandle.persentViewController = self;[pCoreHandle setContainerView:self.view];NSString* pWWWPath = [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:@"Pandora/apps/H5FBED132/www"];NSString* pArgus = @"id=plus.runtime.arguments";pAppHandle = [[[PDRCore Instance] appManager] openAppAtLocation:pWWWPath withIndexPath:@"/form_mobile/login/login.html" withArgs:pArgus withDelegate:nil]; js方法跳转iOS原生控制器页面123456789function getProductById(id,room_no,live_id,product_number)&#123; var newVCobj = plus.ios.newObject("ShowVC"); var UIApplicationClass = plus.ios.importClass("UIApplication"); var UIAppObj = UIApplicationClass.sharedApplication(); var del = plus.ios.invoke(UIAppObj,"delegate"); var appWindowObj = plus.ios.invoke(del,"window"); var appRootController = plus.ios.invoke(appWindowObj,"rootViewController"); plus.ios.invoke(appRootController,"pushViewController:animated:",newVCobj,"YES")&#125; iOS原生控制器跳转html5页面]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统上IntellijIdea+tomcat+mysql环境搭建]]></title>
    <url>%2F2017%2F12%2F22%2FMac%E7%B3%BB%E7%BB%9F%E4%B8%8AIntellijIdea-tomcat-mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Apache Tomcat安装Mac系统自带的Apache是普通服务器，本身只支持html即普通网页，可以通过插件支持PHP,还可以与Tomcat连通(单向Apache连接Tomcat,就是说通过Apache可以访问Tomcat资源。Tomcat无法取访问Appache资源)。Appache只支持静态网页，但像asp,php,cgi,jsp等动态就需要Tomcat来处理。 1、下载Apache Tomcat，在Download里选择对应版本，选择Core里的zip或者tar.gz都可以（这里下载8.5.24版本）2、拷贝Tomcat到目录：/Library 中，并把文件夹名由“apache-tomcat-8.5.24”改为“Tomcat” 3、终端执行sudo chmod 755 /Library/Tomcat/bin/*.sh按回车键后输入管理员密码 4、终端执行sudo sh /Library/Tomcat/bin/startup.sh若出现如下提示则表示安装并运行成功：Using CATALINA_BASE: /Library/TomcatUsing CATALINA_HOME: /Library/TomcatUsing CATALINA_TMPDIR: /Library/Tomcat/tempUsing JRE_HOME: /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home注释：sudo通常为系统超级管理员；755代表用户对该文件拥有读、写、执行的权限，同组其他人员拥有执行和读的权限，没有写的权限，其他用户的权限和同组人员权限一样。777代表user、group、others都有读写和可执行权限。 5、打开浏览器，输入 http://localhost:8080/出现Apache Tomcat页面即表示成功运行 6、在终端中输入命令 sudo sh /Library/Tomcat/bin/shutdown.sh 回车之后可以关闭Tomcat。 7、IP地址过滤tomcat使用一种叫做valves（阀）的机制过滤ip地址。常见的阀（valves）有RemovteAddrValve，可以进行IP地址过滤。阀可以应用在3个级别：Engin、Host、Context。如果你只允许本机地址（localhost）对tomcat服务器进行访问，可以在server.xml中使用下列语句：123&lt;Engine name=”Catalina” defaultHost=”localhost” debug=”0”&gt;&lt;Valve className=”org.apache.catalina.valves.RemoteAddrValve”allow="127.0.0.1,0:0:0:0:0:0:0:1%0,::1"/&gt; Tomcat会使用java.util.regex对IP地址进行匹配。 IntelliJ IDEA下载安装IntelliJ IDEA官网下载旗舰版，使用注册码进行安装。（条件允许请支持正版）IntelliJ IDEA破解，（IDEA最新版2017.3.1的破解码破解失败，这里下载使用的是2017.2.5版本）点击Create New Project创建webApp项目 IntelliJ IDEA配置Tomcat右上角点击Edit configurations添加Tomcat 点击运行，报错提示（这是由于安装的Tomcat访问权限问题）解决办法：终端输入sudo chmod -R 777 /Library/Tomcat/conf/（路径请修改为自己本地安装的路径） 再次点击运行，居然还报错。。。。说是本地8080端口已被占用，原来是自己之前在终端手动启动了Tomcat解决办法：先手动关闭Tomcat，再运行IDEA(因为运行IntelliJ IDEA项目默认会去启动Tomcat) 数据库mysql安装1、下载安装mysql2、下载安装mysql图形管理工具软件MySQL Workbench3、启动mysql,打开MySQL Workbench,点击New Connection，连接本地数据库 Maven下载及配置Maven官网下载apache-maven-3.5.2-bin.tar.gz解压后把文件夹改名为Maven并拷贝到/Library/路径下终端输入vi ~/.bash_profile进入配置文件添加下列两行代码：12export M2_HOME=/Library/Mavenexport PATH=$PATH:$M2_HOME/bin 退出保存后，终端输入source ~/.bash_profile使其生效终端输入mvn -v查看Maven已安装成功的版本 其它域名解析DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53 网络访问服务器过程中会先找本地hosts文件有没有该域名对应的IP，如果有就访问，如果没有则去访问DNS服务器，NDS服务器将域名解析为IP，再进行访问。 获取百度IP （4是指访问请求四次）ping -c 4 www.baidu.com 127.0.0.1 IP是本地环回地址ping -c 4 127.0.0.1 不通，诊断问题：网卡坏了，或者说网卡没有插好 本地hosts文件作用：本地缓存域名与IP地址映射查看hosts文件：cat /etc/hosts 修改hosts文件，添加域名和IP地址映射关系 sudo vi /etc/hosts (vi是一个编辑文件的命令 sudo使用管理员权限)输入i编辑文件自己添加百度ip地址的映射 127.0.0.1 www.baidu.com退出保存 按esc ,接:wq 删除hosts文件添加的记录 sudo vi /etc/hosts把光标移动到要删除的行输入 dd退出保存 按esc ,接:wq :wq!是强制退出 记住登录Cookie和Session机制详解]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置mac本地服务器]]></title>
    <url>%2F2017%2F12%2F21%2F%E9%85%8D%E7%BD%AEmac%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[apache服务器配置mac中已经默认安装了apache服务器，也就是网站服务器，默认该服务是没有启动的 1、终端启动服务器：sudo apachectl -k start输入电脑密码，接着出现类似信息：AH00558: httpd: Could not reliably determine the server’s fully qualified domain name, using xianrongdeMacBook-Pro.local. Set the ‘ServerName’ directive globally to suppress this message此条信息可以忽略如果强迫症犯了，可以输入sudo vi /etc/apache2/httpd.conf进入配置文件。输入i进入编辑状态，查找到#ServerName www.example.com:80这一行，在下一行输入ServerName localhost:80，然后按esc键退出，再输入:wq！保存配置文件。2、在浏览器输入http://localhost后页面显示It works!说明启动成功 3、默认服务器资源文件是放在/Library/WebServer/Documents/这个目录下的，上面访问看到的It works！就是该路径下的index.html.en文件里的内容。 4、自定义网站资源文件放置路径：12345#DocumentRoot "/Library/WebServer/Documents"#&lt;Directory "/Library/WebServer/Documents"&gt;在配置文件里找到上面这两行，在前面添加#注释掉，按照同样的格式从新自定义自己的路径和目录即可DocumentRoot "/Users/xianrong/Sites"&lt;Directory "/Users/xianrong/Sites"&gt; 5、重启服务器：sudo apachectl -k restart 6、这时就可以通过http://localhost/index.html这样访问资源文件了（测试资源文件为index.html） 7、关闭服务器：sudo apachectl -k stop（或sudo httpd -k stop）]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA入坑]]></title>
    <url>%2F2017%2F12%2F19%2FJAVA%E5%85%A5%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前期准备JVM (Java Virtual Machine)：Java虚拟机。JRE (Java Runtime Environment)：Java运行环境，如果要运行Java程序，就需要JRE的支持。JDK (Java Development Kit)：Java开发工具，包含开发Java程序的所有工具,如javac和java等。JDK目录：bin （编译器+解释+其它可执行文件）db （JAVA DB数据库）include （用于本地代码的头文件）src.zip （JDK类库源代码文件）jre （java运行环境）lib （相关类库）注意：(.java文件)编译生成字节码(.class文件)的名称跟里面代码的class名称是一致的。 如果在代码里的class前添加public关键字，那么(.java文件)名称必须和代码里的class的名称一致。反编译工具：XJad 到官网下载对应系统的JDK下载安装IntelliJ IDEA 熟悉基础语法基本数据类型：存放于栈中 引用数据类型： Static关键字：1、确定修饰的内容属于类，附着类的的加载而加载（当JVM把class字节码加载到虚拟机时，static修饰的成员已经自动的加载到内存中）2、可以直接使用当前类的类名访问static成员3、可以通过对象访问static成员（static修饰的成员被该类型的所有对象共享，本质上依然是使用的类名访问，可通过代码反编译查看验证）4、静态方法(static修饰的方法)只能访问静态成员（static修饰的成员） 包(package)：1、划分方便管理，避免名字冲突2、不同包中的类的名字可以相同，当调用时需要加上包名加以区分3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类4、包语法：包名.子包名.子子包名5、包名定义：全部小写，域名倒写.模块名.组件名6、类的名称：包名.类名 访问修饰符:属性: this关键字:类似于OC的self 框架Dom4J（Dom for java）:xml解析 示例代码demo练习项目实战CS与BSCS (Client - Server):客户端 - 服务器，特点是和服务器通讯，Java Swing方向BS（Browser - Server):浏览器 - 服务器，网站就是BS，Java EE方向在开发上来说，最大区别就是 View 层和 Controller 层的设计思路。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS交互]]></title>
    <url>%2F2017%2F12%2F13%2FiOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[iOS中调用JS先写JS操作语句，再通过IOS中的webView执行这个条JS语句。使用UIwebView调用的是stringByEvaluatingJavaScript(from:jsStr）这个方法使用WKWebView调用的是evaluateJavaScript(jsStr) { (result, error) in }示例：增删改查123456789&lt;body&gt; &lt;p id="title"&gt;我的水果清单&lt;/p&gt; &lt;ul&gt; &lt;li class="change"&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 1234567891011121314151617181920// 删除标题let str1 = "document.getElementById('title').remove()"webView.stringByEvaluatingJavaScript(from: str1)// 修改let str2 = "var change = document.getElementsByClassName('change')[0];"let str3 = "change.innerHTML = '榴莲';"print(str2)webView.stringByEvaluatingJavaScript(from: str2 + str3)// 插入let str4 = "var img = document.createElement('img');"let str5 = "img.src = 'xiniu.jpg';"let str6 = "document.body.appendChild(img);"webView.stringByEvaluatingJavaScript(from: str4 + str5 + str6)// 查let str7 = "document.body.outerHTML"let bodyStr = webView.stringByEvaluatingJavaScript(from: str7)print(bodyStr ?? "") JS调用iOS利用WKWebView的新特性MessageHandler来实现JS调用原生方法带来的好处：1、在JS中写起来简单，不用再用创建URL的方式那么麻烦了2、JS传递参数更方便。使用拦截URL的方式传递参数，只能把参数拼接在后面，如果遇到要传递的参数中有特殊字符，如&amp;、=、？等，必须得转换，否则参数解析肯定会出错。示例：在html页面点击登录按钮，把账号和密码传给iOS端;点击html页面的访问相册按钮，访问手机系统相册12345678910111213141516171819202122232425&lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input id="username"&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;密码&lt;/span&gt; &lt;input id="pwd" type="password"&gt; &lt;p&gt;&lt;/p&gt; &lt;button id="loginBtn"&gt;登录&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button id="photoBtn"&gt;访问相册&lt;/button&gt; &lt;script&gt; var username = document.getElementById('username'); var pwd = document.getElementById('pwd'); var loginBtn = document.getElementById('loginBtn'); var photoBtn = document.getElementById('photoBtn'); loginBtn.onclick = function()&#123; window.webkit.messageHandlers.loginInfo.postMessage(&#123;'username':username.value,'password':pwd.value&#125;) &#125; photoBtn.onclick = function()&#123; window.webkit.messageHandlers.getPhoto.postMessage('showPhotos'); &#125; &lt;/script&gt;&lt;/body&gt; 遵守协议WKScriptMessageHandler,UINavigationControllerDelegate,UIPickerViewDelegate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var webView :WKWebView!override func viewDidLoad() &#123; super.viewDidLoad() let url = Bundle.main.url(forResource: "index", withExtension: "html")! let request = URLRequest(url: url) let config = WKWebViewConfiguration() let pf = WKPreferences() pf.javaScriptCanOpenWindowsAutomatically = true pf.minimumFontSize = 40 config.preferences = pf // name:这个参数可以自定义，需要和js里messageHandler对应即可 // window.webkit.messageHandlers.loginInfo.postMessage() // window.webkit.messageHandlers.getPhoto.postMessage() config.userContentController.add(self, name: "loginInfo") config.userContentController.add(self, name: "getPhoto") webView = WKWebView(frame: view.frame, configuration: config) webView.load(request) view.addSubview(webView)&#125;override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) webView.configuration.userContentController.removeScriptMessageHandler(forName: "loginInfo") webView.configuration.userContentController.removeScriptMessageHandler(forName: "getPhoto")&#125;func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123; if message.name == "loginInfo" &#123; if let dic = message.body as? NSDictionary&#123; print(dic["username"] ?? "") print(dic["password"] ?? "") &#125; &#125;else if message.name == "getPhoto" &#123; if message.body as? String == "showPhotos"&#123; showPhotos() &#125; &#125;&#125;func showPhotos()&#123; let imgCtr = UIImagePickerController() imgCtr.sourceType = .photoLibrary self.present(imgCtr, animated: true, completion: nil)&#125; JavaScriptCore框架JavaScriptCore框架是基于Objective-C的封装，只能使用在iOS 7以上。（JavaScriptCore是苹果Safari浏览器的JavaScript引擎，类似于Google的V8引擎） 主要的类1、JSContext — 在OC中创建JavaScript运行的上下文环境123456789101112131415161718192021222324- (instancetype)init; // 在特定的对象空间上创建JSContext对象，获得JavaScript运行的上下文环境- (instancetype)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;// 运行一段js代码，输出结果为JSValue类型- (JSValue *)evaluateScript:(NSString *)script;- (JSValue *)evaluateScript:(NSString *)script withSourceURL:(NSURL *)sourceURL;// 获取当前正在运行的JavaScript上下文环境+ (JSContext *)currentContext;// 返回结果当前执行的js函数 function () &#123; [native code] &#125; + (JSValue *)currentCallee; // 返回结果当前方法的调用者[object Window] + (JSValue *)currentThis; // 返回结果为当前被调用方法的参数 + (NSArray *)currentArguments; // js的全局变量 [object Window] @property (readonly, strong) JSValue *globalObject; 示例：创建JSContext12345678910// 1.这种方式需要传入一个JSVirtualMachine对象，如果传nil，会导致应用崩溃的。JSVirtualMachine *JSVM = [[JSVirtualMachine alloc] init];JSContext *JSCtx = [[JSContext alloc] initWithVirtualMachine:JSVM];// 2.这种方式，内部会自动创建一个JSVirtualMachine对象，可以通过JSCtx.virtualMachine// 看其是否创建了一个JSVirtualMachine对象。JSContext *JSCtx = [[JSContext alloc] init];// 3. 通过webView的获取JSContext。JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; 2、JSValue — 可以转成OC数据类型，JSContext强引用着JSValueOC与JS数据类型对比、转换1234567891011121314151617181920212223// 在context创建BOOL的JS变量 + (JSValue *)valueWithBool:(BOOL)value inContext:(JSContext *)context; // 将JS变量转换成OC中的BOOL类型 - (BOOL)toBool; // 修改JS对象的属性的值 - (void)setValue:(id)value forProperty:(NSString *)property; // JS中是否有这个对象 @property (readonly) BOOL isUndefined; // 比较两个JS对象是否相等 - (BOOL)isEqualToObject:(id)value; // 调用者JSValue对象为JS中的方法名称，arguments为参数，调用JS中Window直接调用的方法 - (JSValue *)callWithArguments:(NSArray *)arguments;// 调用者JSValue对象为JS中的全局对象名称，method为全局对象的方法名称，arguments为参数 - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments;// JS中的结构体类型转换为OC + (JSValue *)valueWithPoint:(CGPoint)point inContext:(JSContext *)context; 3、JSExport — 一个协议类，通过协议的方式把OC的属性和方法暴露给JS使用(自定义一个继承自JSExport协议的协议，并实现协议) 4、JSManagedValue — 主要用途是解决JSValue对象在Objective-C 堆上的安全引用问题。把JSValue 保存进Objective-C 堆对象中是不正确的，这很容易引发循环引用，而导致JSContext不能释放。这个类主要是将JSValue对象转换为JSManagedValue的API12JSManagedValue *jsManagedValue = [JSManagedValue managedValueWithValue:jsValue];[_context.virtualMachine addManagedReference:jsManagedValue]; 5、JSVirtualMachine — JS虚拟机，也就是说JavaScript是在一个虚拟的环境中执行，而JSVirtualMachine为其执行提供底层资源。有独立的堆空间和垃圾回收机制，运行在不同虚拟机环境的JSContext可以通过此类通信。一个JSVirtualMachine实例，代表一个独立的JavaScript对象空间，并为其执行提供资源。它通过加锁虚拟机，保证JSVirtualMachine是线程安全的，如果要并发执行JavaScript，那我们必须创建多个独立的JSVirtualMachine实例，在不同的实例中执行JavaScript。通过alloc/init就可以创建一个新的JSVirtualMachine对象。但是我们一般不用新建JSVirtualMachine对象，因为创建JSContext时，如果我们不提供一个特性的JSVirtualMachine，内部会自动创建一个JSVirtualMachine对象。 OC调用JS方法示例一：OC调用JS（页内js）方式1：使用JSContext的方法-evaluateScript1234- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; JSContext *context = [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; [context[@"payResult"] callWithArguments:@[@"支付成功！"]];&#125; 方式2：使用JSValue的方法-callWithArguments12NSString *jsStr = [NSString stringWithFormat:@"payResult('%@')",@"支付成功！"];[[JSContext currentContext] evaluateScript:jsStr]; 示例二：OC调用JS(页外js)的平方方法JS文件（square.js）的代码123var square = function (n) &#123; return n * n&#125;; OC中的代码12345678910NSString * jsPath = [[NSBundle mainBundle] pathForResource:@"square.js" ofType:nil];NSString * jsStr = [NSString stringWithContentsOfFile:jsPath encoding:NSUTF8StringEncoding error:nil];JSContext *context = [[JSContext alloc] init];[context evaluateScript:jsStr];JSValue *jsFunction = context[@"square"];JSValue *result = [jsFunction callWithArguments:@[@4]];NSLog(@"square(4) = %d", [result toInt32]); JS调用OC的方法第一种使用block的方式：将OC中的单个方法（即block）暴露给JS调用，JavaScriptCore框架会自动将这个Block包装成一个JS方法。注意：使用black可能造成内存泄露的问题不要在Block中直接使用JSValue，建议把JSValue当做参数传到Block中，这样Block就不会强引用JSValue了。不要在Block中直接使用JSContext，可以使用[JSContext currentContext] 方法来获取当前的Context。示例：12345678910111213&lt;html&gt; &lt;header&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;/header&gt; &lt;body&gt; &lt;button type="button" onclick="btnClick()"&gt;快点我呀&lt;/button&gt; &lt;script type="text/javascript"&gt; function btnClick() &#123; share('为了艾泽拉斯','为了联盟','为了部落'); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324NSURL *url = [[NSBundle mainBundle] URLForResource:@"jsScriCode" withExtension:@"html"];[_webView loadRequest:[[NSURLRequest alloc] initWithURL:url]];- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; // 获取html页内js上下文 JSContext *context = [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; NSLog(@"异常信息：%@", exceptionValue); &#125;; //js里调用share方法时就会调用这里的block内容 context[@"share"] = ^() &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"js里调原生block" message:@"这是OC原生的弹窗" delegate:self cancelButtonTitle:@"收到" otherButtonTitles:nil]; [alertView show]; &#125;); //获取js的share方法传过来的参数数组 NSArray *args = [JSContext currentArguments]; for (JSValue *jsVal in args) &#123; NSLog(@"%@", jsVal.toString);// 为了艾泽拉斯、为了联盟、为了部落 &#125;&#125; 第二种使用JSExport协议的方式：使用JSExport协议将OC中某个对象直接暴露给JS使用，而且在JS中使用就像调用JS的对象一样自然示例：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;header&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;script type="text/javascript"&gt; var nativePhotosCallback = function(photos) &#123; alert(photos); alert(NativeClassName.myName) &#125; var shareBtnClick = function() &#123; var shareInfo = JSON.stringify(&#123;"title": "标题", "content": "内容", "url": "https://www.baidu.com"&#125;); NativeClassName.shareBtnClick(shareInfo); &#125; var nativeShareResultCallback = function()&#123; alert('success'); &#125; var btnClick = function() &#123; NativeClassName.macroFunction(18,1.82); &#125; &lt;/script&gt; &lt;/header&gt; &lt;body&gt; &lt;button type="button" onclick="NativeClassName.cameraBtnClick()"&gt;调起相册&lt;/button&gt; &lt;button type="button" onclick="shareBtnClick()"&gt;帮我分享一下&lt;/button&gt; &lt;button type="button" onclick="btnClick()"&gt;以宏的方式调用&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#import "ViewController.h"#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@protocol JSExportDelegate &lt;JSExport&gt;@property (nonatomic,copy) NSString * myName;- (void)cameraBtnClick;- (void)shareBtnClick:(NSString *)shareString;JSExportAs (macroFunction,-(void)testMacroFunction:(NSInteger)age height:(CGFloat)height);@end@interface ViewController () &lt;UIWebViewDelegate, JSExportDelegate&gt;@property (nonatomic, strong) JSContext *jsContext;@property (nonatomic, strong) UIWebView * webView;@end@implementation ViewController@synthesize myName;- (void)viewDidLoad &#123; [super viewDidLoad]; self.myName = @"瓦里安.乌瑞恩"; UIWebView * webView = [[UIWebView alloc]initWithFrame:self.view.bounds]; webView.delegate = self; NSURL *url = [[NSBundle mainBundle] URLForResource:@"texth5" withExtension:@"html"]; [webView loadRequest:[[NSURLRequest alloc] initWithURL:url]]; [self.view addSubview:webView];&#125;#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; self.jsContext = [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; self.jsContext[@"NativeClassName"] = self; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; NSLog(@"异常信息：%@", exceptionValue); &#125;;&#125;#pragma mark - JSExportDelegate- (void)cameraBtnClick&#123; NSLog(@"调起原生相册"); // 获取到照片后再回调js的nativePhotosCallback方法并把图片传过去 JSValue *phoCallback = self.jsContext[@"nativePhotosCallback"]; [phoCallback callWithArguments:@[@"photos"]]; // NSString *jsStr = [NSString stringWithFormat:@"nativePhotosCallback('%@')",@"photos"];// [self.jsContext evaluateScript:jsStr];&#125;- (void)shareBtnClick:(NSString *)shareString &#123; NSLog(@"分享内容:%@", shareString); // 分享成功回调js的nativeShareResultCallback方法 JSValue *shareCallback = self.jsContext[@"nativeShareResultCallback"]; [shareCallback callWithArguments:nil];&#125;-(void)testMacroFunction:(NSInteger)age height:(CGFloat)height&#123; NSLog(@"年龄：%zd,身高：%f",age,height);&#125;@end 内存管理注意事项1、不要在JS中给OC对象增加成员变量2、OC对象不要直接强引用JSValue对象,解决方案：苹果推出了一种新的引用关系，叫conditional retain，有条件的强引用，JSManagedValue就是苹果用来实现conditional retain的类。JSManagedValue弱引用着JSValue 补充：关于WKWebView 与JavaScriptCore，由于WKWebView 不支持通过如下的KVC的方式创建JSContext：1JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; 但WKWebView与JS交互有特有的方式：MessageHandler，在上文已介绍过。 多线程说多线程之前得先说下另一个类JSVirtualMachine，它为JavaScript的运行提供了底层资源，有自己独立的堆栈以及垃圾回收机制。JSVirtualMachine还是JSContext的容器，可以包含若干个JSContext，在一个进程中，你可以有多个JSVirtualMachine，里面包含着若干个JSContext，而JSContext中又有若干个JSValue。需要注意的是，你可以在同一个JSVirtualMachine的不同JSContext中，互相传递JSValue，但是不能再不同的JSVirtualMachine中的JSContext之间传递JSValue。这是因为，每个JSVirtualMachine都有自己独立的堆栈和垃圾回收器，一个JSVirtualMachine的垃圾回收器不知道怎么处理从另一个堆栈传过来的值。 JavaScriptCore提供的API本身就是线程安全的，你可以在不同的线程中，创建JSValue，用JSContext执行JS语句，但是当一个线程正在执行JS语句时，其他线程想要使用这个正在执行JS语句的JSContext所属的JSVirtualMachine就必须得等待，等待前前一个线程执行完，才能使用这个JSVirtualMachine。 当然，这个强制串行的粒度是JSVirtualMachine，如果你想要在不用线程中并发执行JS代码，可以为不同的线程创建不同JSVirtualMachine。]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的CRUD]]></title>
    <url>%2F2017%2F12%2F12%2FJS%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[window1、window的特点所有全局变量都是它的变量所有全局函数都是它的函数2、通过JS代码动态跳转页面12location.href = 'http://www.baidu.com';window.loction.href = 'http://www.baidu.com'; document1、document的用途：可以用来获得网页中的任何一个元素可以创建HTML元素动态的获取网页中所有的节点可以动态的对节点进行CRUD（增删改查）……2、常用方法getElementById (id名)getElementsByClassName (className)getElementsByName (标签的内部属性name)getElementsByTagName (标签名) Create1、write直接写入1234document.write('hello world!');document.write('&lt;img src="img/img_03.jpg"&gt;');document.write('&lt;input&gt;');document.write('&lt;input type="date"&gt;'); 2、先拿到修改再添加12345678var btn = document.createElement('button');btn.innerHTML = '我们不一样';btn.style.border = '5px solid #ddd';btn.style.background = 'red';// 把按钮加入到指定的div标签里var div = document.getElementsByClassName('test')[0];div.appendChild(btn); // 添加到末尾// div.insertBefore(btn) 指定添加位置 Delete12var img = document.getElementsByClassName('icon')[0];img.remove(); Update123var a = document.getElementsByClassName('gx')[0];a.href = 'https://www.baidu.com';a.target = '_blank'; Retrieve1234567891011121314console.log(document.body.children);console.log(document.body.innerHTML);console.log(document.body.outerHTML);function find(obj)&#123; for(var i = 0; i &lt; obj.length; i++)&#123; console.log(obj[i]); &#125;&#125;find(document.body.children);var dives = document.getElementsByClassName('test1');find(dives); 其它构造函数 实例化对象12345678910111213141516function Dog(name, age) = &#123; this.name = name; this.age = age; this.run = function()&#123; console.log(this.name + '- run'); &#125;; this.eat = function(meat)&#123; console.log(this.name + '-eat-' + meat); &#125;;&#125;;var dog1 = new Dog('wangcai', 5);var dog2 = new Dog('hhhhh');dog1.run();dog2.run();// 如果没有传值，则会是undifiend || 和 &amp;&amp;提出需求： var name1 = ‘’; var name2 = ‘name2’; var name3 = ‘name3’;找出这三个中第一个有值的赋给name12var name = name1 || name2 || name3;// js中||运算符的返回值：返回第一个为真（有值就为真）的值 123456var age = 18;if (age &gt;= 18)&#123; console.log('成年了！！！');&#125;// 等价于上面：（age &gt;= 18） &amp;&amp; console.log('成年了');]]></content>
      <categories>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐变色效果]]></title>
    <url>%2F2017%2F12%2F06%2F%E6%B8%90%E5%8F%98%E8%89%B2%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[使用Core Graphics框架下的Quartz 2D实现渐变效果Quartz 2D 的渐变方式分为两种：1、线性渐变：渐变色以直线方式从开始位置逐渐向结束位置渐变2、放射性渐变：以中心点为圆心从起始渐变色向四周辐射，直到终止渐变色使用中我们可以直接绘制一个渐变，也可以将渐变填充到现有的图形路径上 使用CAGradientLayer来实现渐变背景CAGradientLayer 是 CALayer 的子类，可以理解为一个渐变层。如果使用的是透明的颜色，还可以做到透明渐变。CAGradientLayer 目前只能实现线性渐变，还不能实现放射性渐变。CAGradientLayer 对象最主要的就是如下 4 个属性：1、colors：颜色数组，定义渐变层的各个颜色。2、locations（可选）：决定每个渐变颜色的终止位置，这些值必须是递增的，数组的长度和 colors 的长度最好一致。3、startPoint（可选）：渲染的起始位置，默认值是：[.5,0]（具体坐标系参考下图）4、endPoint（可选）：渲染的终止位置，默认值是：[.5,1]（具体坐标系参考下图）]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(转)]]></title>
    <url>%2F2017%2F11%2F14%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E8%BD%AC)%2F</url>
    <content type="text"><![CDATA[汇编语言（Assembly Language）：用符号代替0和1，比机器语言便于阅读和记忆。学习汇编语言的用途：弄清代码的本质推荐阅读：《汇编语言》王爽 汇编语言的特点1、可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能2、能够不受编译器的限制，对生成的二进制代码进行完全的控制3、目标代码简短，占用内存少，执行速度快4、汇编指令是机器指令的助记符，同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性5、知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护6、不区分大小写，比如mov和MOV是一样的 汇编语言种类1、8086汇编（8086处理器是16bit的CPU）2、Win32汇编3、Win64汇编4、ARM汇编（嵌入式、Mac、iOS）5、…… 学前须知1、要想学好汇编语言，首先要对CPU等硬件结构有一定的了解2、软件\程序的执行过程3、最为关键的是需要了解CPU和内存4、在学习汇编语言过程中，遇到的绝大部分指令都是跟内存、CPU有关的]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程]]></title>
    <url>%2F2017%2F11%2F13%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。函数式编程特点：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）需求:写一个加法计算器,并且加法计算器自带判断是否等于某个值.1、创建计算机对象，封装对应的需求实现方法12345678910111213141516171819@interface Caculator : NSObject@property (nonatomic, assign) int result;@property (nonatomic, assign) BOOL isEqule;- (instancetype)add:(int(^)(int result))block;- (instancetype)equle:(BOOL(^)(int result))block;@end@implementation Caculator- (instancetype)add:(int (^)(int result))block&#123; _result = block(_result); return self;&#125;- (instancetype)equle:(BOOL (^)(int))block&#123; _isEqule = block(_result); return self;&#125;@end 2、外部调用，把一个操作写成一系列的方法123456789101112Caculator *caculator = [[Caculator alloc] init];BOOL isEqule = [[[caculator add:^(int result)&#123; result += 10; result += 20; result += 30; result += 40; return result; &#125;] equle:^BOOL(int result) &#123; return result == 100; &#125;] isEqule]; NSLog(@"%d",isEqule); Swift的函数式编程一.函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用二. 函数能够捕获存在于其局部作用域之外的变量三. 有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式 1、把函数赋值给变量12345func printInt(i: Int) &#123; print("you passed \(i)")&#125;let funVar = printIntfunVar(2) //you passed 2 2、把函数作为另一个函数的参数12345func useFunction(function: (Int) -&gt; () )&#123; function(3)&#125;useFunction(function: printInt) // you passed 3useFunction(function: funVar) // you passed 3 3、把函数作为另一个函数的返回值12345678func returnFunc() -&gt; (Int) -&gt; String&#123; func innerFunc(i:Int) -&gt; String&#123; return "you passed\(i)" &#125; return innerFunc&#125;let myFunc = returnFunc()myFunc(4) 4、函数可以捕获存在于它们作用范围之外的变量1234567891011121314func counterFunc() -&gt; (Int) -&gt; String &#123; var counter = 0 func innerFunc(i: Int ) -&gt; String &#123; counter += i // counter is captured return "running total: \(counter)" &#125; return innerFunc&#125;let f = counterFunc()f(3) // running total: 3f(4) // running total: 7let g = counterFunc()g(2) // running total: 2g(2) // runningtotal: 4 innerFunc捕获了counter变量属性一个函数和它所捕获的变量环境组合起来被称为闭包上面 f 和 g 都是闭包的 例子，因为它们捕获并使用了一个在它们外部声明的非局部变量 counter。 闭包闭包指的是一个函数以及被它所捕获的所有变量的组合。而使用{ } 来创建的函数被称为闭包表达式可以把闭包表达式理解为匿名的函数，可以理解为把闭包赋值给了以函数名为名的变量闭包的优点：简洁，像是 map 这样的将一个快速实现的函数传递给另一个函数时，这个特点更为明显 如果函数的最后一个参数是闭包表达式的话，你可以将这个闭包表达式移到函数调用的 圆括号的外部。这样的尾随闭包语法如果一个函数除了闭包表达式外没有别的参数，那么方法名后面的调用时的圆括 号也可以一并省略。 1、使用func定义函数1234func doubler(i: Int) -&gt; Int &#123; return i * 2&#125;[1, 2, 3, 4].map(doubler) // [2, 4, 6, 8] 2、使用闭包表达式的语法来写相同的函数，像之前那样将它传给 map:12let doublerAlt = &#123; (i: Int) -&gt; Int in return i*2 &#125;[1, 2, 3, 4].map(doublerAlt) // [2, 4, 6, 8] 3、使用Swift 中的一些特性，来让代码更加简洁1[1, 2, 3].map&#123;$0*2 &#125; // [2, 4, 6]]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式编程]]></title>
    <url>%2F2017%2F11%2F13%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[不需要考虑调用顺序，只考虑结果，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，万物皆是流。代表作：KVO运用、RxSwift框架 RxSwift是整个ReactiveX里针对Swift语言的库，ReactiveX里面还有针对Java，JS，.Net, Swift，Android，PHP等使用的库，它们内部都用了ReactiveX的逻辑思想。 ReactiveX是Reactive Extensions的缩写，一般简写为Rx。Rx(函数库) = Observables(异步数据流) + LINQ(操作符查询异步数据流) + Schedulers(参数化异步数据流的并发处理)。Rx是一种编程模型，最初由微软开发，结合了观察者模式、迭代器模式和函数式编程的精华，来更方便地处理异步数据流。其中最重要的一个概念是 Observable。Rx提供了观察者模式来处理事件序列，还提供了很多强大的操作符，操作符让你可以变换、组合、操纵和处理Observable发射的数据；让你可以用声明式的风格组合异步操作序列，它拥有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。 RxSwift 也被描述为函数响应式编程(Functional Reactive Programming, FRP)框架。推荐参考学习：RxSwiftwhy use rx?Marbles使用 RxSwift 进行响应式编程是时候学习 RxSwift 了坠入链式编程的幻乐里–用RxSwift仿写知乎日报RxSwift/Documentation/的中文翻译ReactiveX文档中文翻译]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2017%2F11%2F13%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[使用泛型代码，你可以 写出可重用的函数和数据结构，只要它们满足你所定义的约束，它们就能够适用于各种类型。比如，像是 Array 和 Set 等多个类型，实际上是它们中的元素类型就是泛型抽象。我们也可以 创建泛型方法，它们可以对输入或者输出的类型进行泛型处理。func identity(input: A) -&gt; A 就定义了一个可以作用于任意类型 A 的函数。某种意义上，我们甚至可以认为带有关联类型的协议是 “泛型协议”。关联类型允许我们对特定的实现进行抽 象。IteratorProtocol 协议就是一个这样的例子:它所生成的 Element 就是一个泛型。 泛型编程的目的是表达算法或者数据结构所要求的核心接口。使用泛型数据类型来重构代码，能使它们易于测试，更加灵活。 重载重载：拥有同样名字，但是参数或返回类型不同的多个方法互相称为重载方法。123456789101112131415func raise(_ base: Double, to exponent: Double) -&gt; Double &#123; return pow(base, exponent)&#125;func raise(_ base: Float, to exponent: Float) -&gt; Float &#123; return powf(base, exponent)&#125;let double = raise(2.0, to: 3.0)print(double) // 8.0print(type(of: double)) // Doublelet float:Float = raise(2.0, to: 3.0)print(float) // 8.0print(type(of: float)) // Float Swift 有一系列的复杂规则来确定到底使用哪个重载函数，这套规则基于函数是否是泛型，以及传入的参数是怎样的类型来确定使用优先级。整套规则十分复杂，不过它们可以被总结为一句话，那就是 “选择最具体的一个”。也就是说，非通用的函数会优先于通用函数被使用。 重载的使用是在编译期间静态决定的。也就是说，编译器会依据变量的静态类型来决定要调用哪一个重载，而不是在运行时根据值的动态类型来决定。 泛型泛型编程让我们的资源类型更加简单，耦合更少，这也让测试更加容易 1、创建泛型数据类型，泛型函数1234567891011121314151617181920212223242526272829303132struct Resource&lt;A&gt; &#123; let path: String let parse: (Any) -&gt; A? let webserviceURL : URL = URL(string: "https://baidu.com")!&#125;extension Resource &#123; func loadSynchronously(callback: (A?) -&gt; ()) &#123; let resourceURL = webserviceURL.appendingPathComponent(path) let data = try? Data(contentsOf: resourceURL) let json = data.flatMap &#123; try? JSONSerialization.jsonObject(with: $0, options: []) &#125; callback(json.flatMap(parse)) &#125;&#125;struct User&#123; var name:String? var age = 0&#125;// 辅助函数： 将一个 Any 转换为一个 Any 的数组func jsonArray&lt;A&gt;(_ transform: @escaping (Any) -&gt; A?) -&gt; (Any) -&gt; [A]? &#123; return &#123; array in guard let array = array as? [Any] else &#123; return nil &#125; return array.flatMap(transform)&#125;&#125;let usersResource: Resource&lt;[User]&gt; = Resource(path: "/users", parse: jsonArray(User.init)) 2、标准库中的 min函数1234T是泛型参数func min&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; T &#123; return y &lt; x ? y : x&#125; 3、全模块优化 之 泛型特化Swift 中有一个叫做 @_specialize 的半官方标签12345@_specialize(Int)@_specialize(String)public func min&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; T &#123; return y &lt; x ? y : x&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式编程]]></title>
    <url>%2F2017%2F11%2F12%2F%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[链式编程：将多个操作通过点号（.）链接在一起成为一句代码，代表作：用OC写的masonry框架我们平时编码习惯是把事情封装到一个方法中。而链式编程思想则是把要做的事情封装到block，给外界提供一个返回这个Block的方法链式编程思想方法的特点：（1）方法的返回值必须是block（2）block参数：放需要操作的内容（3）block返回值:方法调用者链式编程的优点：增加代码可读性，利用block的特点使代码高聚合示例：实现简易计算器1、创建计算制造者123456789101112131415161718192021222324@interface CaculatorMaker : NSObject@property (nonatomic, assign) int result;- (CaculatorMaker *(^)(int num))add;- (CaculatorMaker *(^)(int num))multy;@end@implementation CaculatorMaker- (CaculatorMaker *(^)(int num))multy&#123; return ^(int num)&#123; _result *= num; return self; &#125;;&#125;- (CaculatorMaker * (^)(int num))add&#123; return ^(int num)&#123; _result += num; return self; &#125;;&#125;@end 2、给NSObject增加一个分类方法123456789101112@interface NSObject (Caculator)+ (int)makeCaculator:(void(^)(CaculatorMaker *))block;@end@implementation NSObject (Caculator)+ (int)makeCaculator:(void (^)(CaculatorMaker *))block&#123; CaculatorMaker *maker = [[CaculatorMaker alloc] init]; block(maker); return maker.result;&#125;@end 3、外界调用1234567int result = [NSObject makeCaculator:^(CaculatorMaker *maker) &#123; maker.add(10).add(20); maker.add(30).add(40); maker.multy(3).add(5); maker.multy(4);&#125;];NSLog(@"%d",result); Swift中体验链式编程链式代码在 Swift 中有着比 Objective-C 天然的优势以下部分摘录自webfrogs写的Swift 实践篇之链式 UI 代码1、避免命名冲突由于是对UIView做的方法扩展，所以存在命名冲突的隐患。所以先为方法定义一个个性前缀 xr123456789101112131415161718192021222324import Foundationpublic protocol NamespaceWrappable &#123; associatedtype XRWrapperType var xr: XRWrapperType &#123; get &#125; static var xr: XRWrapperType.Type &#123; get &#125;&#125;public extension NamespaceWrappable &#123; var xr: NamespaceWrapper&lt;Self&gt; &#123; return NamespaceWrapper(value: self) &#125; static var xr: NamespaceWrapper&lt;Self&gt;.Type &#123; return NamespaceWrapper.self &#125;&#125;public struct NamespaceWrapper&lt;T&gt; &#123; public let wrappedValue: T public init(value: T) &#123; self.wrappedValue = value &#125;&#125; 2、给UIView的子类做链式支持123456789101112131415161718192021222324import UIKitimport SnapKitextension UIView: NamespaceWrappable &#123; &#125;extension NamespaceWrapper where T: UIView &#123; public func adhere(toSuperView: UIView) -&gt; T &#123; toSuperView.addSubview(wrappedValue) return wrappedValue &#125; @discardableResult public func layout(snapKitMaker: (ConstraintMaker) -&gt; Void) -&gt; T &#123; wrappedValue.snp.makeConstraints &#123; (make) in snapKitMaker(make) &#125; return wrappedValue &#125; @discardableResult public func config(_ config: (T) -&gt; Void) -&gt; T &#123; config(wrappedValue) return wrappedValue &#125;&#125; config 函数的闭包参数在实际使用中，闭包的第一个参数类型可以具体到 UIView 的不同子类上。 实例调用12345678910111213releaseBtn = UIButton(type: .custom) .xr.adhere(toSuperView: view) .xr.layout &#123; make in make.width.height.equalTo(40) make.right.bottom.equalToSuperview().offset(-15) &#125; .xr.config&#123; btn in btn.setTitle("发布", for: .normal) btn.titleLabel?.font = UIFont.systemFont(ofSize: 15) btn.layer.cornerRadius = 20 btn.layer.masksToBounds = true btn.backgroundColor = kThemeColor &#125; 也可以灵活抽取config共用部分12345678910111213141516171819202122let btnConfiger = &#123; (btn: UIButton) in btn.setTitle("发布", for: .normal) btn.titleLabel?.font = UIFont.systemFont(ofSize: 15) btn.layer.cornerRadius = 20 btn.layer.masksToBounds = true btn.backgroundColor = kThemeColor &#125; releaseBtn = UIButton(type: .custom) .xr.adhere(toSuperView: view) .xr.layout &#123; make in make.width.height.equalTo(40) make.right.bottom.equalToSuperview().offset(-15) &#125; .xr.config(btnConfiger) // 覆盖标题 releaseBtn.xr.config &#123; (btn) in btn.setTitle("啦啦", for: .normal) &#125; releaseBtn.setTitle("安慰", for: .normal) Swift和OC混用的链式UI编程实践旧项目里的OC一下子不能迁移到Swift上，可以先在新需求上使用Swift编码1、先做好OC与Swift混编设置2、因为旧项目里使用的是Masonry框架做自动布局，所以只需改动一下上文中NamespaceWrapper协议扩展里的layout方法即可1234567@discardableResult public func layout(masonryMaker: (MASConstraintMaker!) -&gt; Void) -&gt; T &#123; wrappedValue.mas_makeConstraints &#123; (make) in masonryMaker(make) &#125; return wrappedValue &#125; 3、链式UI编码实践调用12345678910let bgV = UIView() .xr.adhere(toSuperView: view) .xr.layout &#123; (make) in make.top.mas_equalTo()(view)?.offset()(15) make.left.right().mas_equalTo()(view) make.height.equalTo()(88) &#125; .xr.config &#123; (bgView) in bgView.backgroundColor = UIColor.white &#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS学习渠道]]></title>
    <url>%2F2017%2F11%2F10%2FiOS%E5%AD%A6%E4%B9%A0%E6%B8%A0%E9%81%93%2F</url>
    <content type="text"><![CDATA[核心途径1、WWDC开发者大会视频2、苹果官方文档 查看每个版本更新的内容：General -&gt; Guides -&gt; iOS x.x API Diffs 需要时按需查阅：Sample Code(示例代码) Guides(指南) Reference(API参考) 网站githubcocoachinaobjc中国优秀博客汇总]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAShapeLayer融合绘图]]></title>
    <url>%2F2017%2F11%2F07%2FCAShapeLayer%E8%9E%8D%E5%90%88%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[CAShapeLayer属于Core Animation框架下。CAShapeLayer 是 CALayer 的子类，但是比 CALayer 更灵活，可以画出各种图形。CAShapeLayer 还有一个神奇的属性 path 用这个属性配合上 UIBezierPath 这个类就可以达到超神的效果。实现效果：普通图片 和 CAShapeLayer绘制出来的形状 进行融合 123456789101112131415161718192021222324252627@implementation CAShapeLayer (ViewMask)+ (instancetype)createMaskLayerWithView : (UIView *)view&#123; CGFloat viewWidth = CGRectGetWidth(view.frame); CGFloat viewHeight = CGRectGetHeight(view.frame); CGFloat rightSpace = 10.; CGFloat topSpace = 15.; CGPoint point1 = CGPointMake(0, 0); CGPoint point2 = CGPointMake(viewWidth-rightSpace, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point4 = CGPointMake(viewWidth, topSpace); CGPoint point5 = CGPointMake(viewWidth-rightSpace, topSpace+10.); CGPoint point6 = CGPointMake(viewWidth-rightSpace, viewHeight); CGPoint point7 = CGPointMake(0, viewHeight); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = path.CGPath; return layer;&#125;@end 12345UIView *view = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 80, 100)];view.backgroundColor = [UIColor orangeColor];[self.view addSubview:view];CAShapeLayer *layer = [CAShapeLayer createMaskLayerWithView:view];view.layer.mask = layer; MaskCALayer有一个属性叫做mask，通常被称为蒙版图层，这个属性本身也是CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子视图，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子视图。不同于一般的subLayer，mask定义了父图层的可见区域，简单点说就是最终父视图显示的形态是父视图自身和它的属性mask的交集部分。mask图层的color属性是无关紧要的，真正重要的是它的轮廓，mask属性就像一个切割机，父视图被mask切割，相交的部分会留下，其他的部分则被丢弃。CALayer的蒙版图层真正厉害的地方在于蒙版图层不局限于静态图，任何有图层构成的都可以作为mask属性，这意味着蒙版可以通过代码甚至是动画实时生成。]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2F2017%2F11%2F07%2F%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线。 曲线定义：起始点、终止点（也称锚点）、控制点。通过调整控制点，贝塞尔曲线的形状会发生变化。 1962年，法国数学家Pierre Bézier第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，因此按照这样的公式绘制出来的曲线就用他的姓氏来命名，称为贝塞尔曲线。以下公式中：B(t)为t时间下点的坐标；P0为起点,Pn为终点,Pi为控制点。 一阶贝塞尔曲线(线段)：意义：由 P0 至 P1 的连续点，描述的一条线段 二阶贝塞尔曲线(抛物线)：原理: 由 P0 至 P1 的连续点 Q0，描述一条线段。 由 P1 至 P2 的连续点 Q1，描述一条线段。 由 Q0 至 Q1 的连续点 B(t)，描述一条二次贝塞尔曲线。经验：P1-P0为曲线在P0处的切线。 三阶贝塞尔曲线： 高阶贝塞尔曲线通用公式：四阶贝塞尔曲线：五阶贝塞尔曲线：]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView实现多选且组内单选]]></title>
    <url>%2F2017%2F11%2F07%2FUICollectionView%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%80%89%E4%B8%94%E7%BB%84%E5%86%85%E5%8D%95%E9%80%89%2F</url>
    <content type="text"><![CDATA[1、设置UICollectionView可以多选：self.collectionV.allowsMultipleSelection = YES;2、在数据模型中添加select属性作为记录状态，添加indexPath属性作为拿去对应的Cell3、取消选中：[collectionView deselectItemAtIndexPath:skut.indexPath animated:YES];4、选中：[collectionView selectItemAtIndexPath:indexPath animated:YES scrollPosition:UICollectionViewScrollPositionNone];5、获取所有选中的：NSArray * selectIndexPaths = collectionView.indexPathsForSelectedItems;1234567891011121314151617181920212223242526272829303132333435-(void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath&#123; CommodityTypeCell * cell = (CommodityTypeCell*)[collectionView cellForItemAtIndexPath:indexPath]; [cell setBackgroundColor:[UIColor grayColor]]; if (collectionView.indexPathsForSelectedItems.count!=self.commodity.proAttributeList.count) &#123; // 做对应的业务处理（比如商品分类标签，改为显示价格区间） &#125;&#125;-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; // 取消当前组内已选中的 CommodityType * type = self.commodity.proAttributeList[indexPath.section]; for (SkuList * skut in type.attribute_vals) &#123; if (skut.select == YES) &#123; skut.select = NO; CommodityTypeCell * oldCell = (CommodityTypeCell*)[collectionView cellForItemAtIndexPath:skut.indexPath]; [oldCell setBackgroundColor:[UIColor grayColor]]; [collectionView deselectItemAtIndexPath:skut.indexPath animated:YES];// 取消选中 &#125; &#125; // 选中当前点击的item SkuList * sku = type.attribute_vals[indexPath.item]; sku.select = YES; sku.indexPath = indexPath; CommodityTypeCell * cell = (CommodityTypeCell*)[collectionView cellForItemAtIndexPath:indexPath]; [collectionView selectItemAtIndexPath:indexPath animated:YES scrollPosition:UICollectionViewScrollPositionNone];// 需要添加选中 [cell setBackgroundColor:[UIColor orangeColor]]; if (collectionView.indexPathsForSelectedItems.count!=self.commodity.proAttributeList.count) &#123; // 做对应的业务处理（比如商品分类标签，显示该商品的唯一价格和库存） &#125;&#125;]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift的协议]]></title>
    <url>%2F2017%2F10%2F17%2FSwift%E7%9A%84%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[我们知道Swift拥有函数、泛型、协议的特性，它们之间的协同工作能让代码的动态特性变得异常强大。Swift 协议可以被用作代理，也可以让你对接口进行抽象 (比如 IteratorProtocol 和 Sequence)。Swift 协议与 OC 的协议最大的不同：（1）可以让结构体和枚举类型满足协议（2）可以有关联类型（3）通过协议扩展的方式为协议添加方法实现协议允许我们进行动态派发，也就是说，在运行时程序会根据消息接收者的类型去选择正确的方法实现。 Swift协议的特性： 可以以追溯的方式来修改任意类型，让它们满足协议。 可以使用完整的方法实现来扩展一个协议。 可以当做类型约束,也可以当做独立类型（关联类型的协议、Self约束的协议）。 代码共享可以通过协议和协议扩展的方式实现代码共享。协议扩展是一种可以在不共享基类的前提下共享代码的方法。协议定义了一组最小可行的方法集合，以供类型进行实现。而类型通过扩展的方式在这些最小方法上实现更多更复杂的特性。 通过协议进行代码共享 与 通过继承的共享 相比有这几个优势:1、我们不需要被强制使用某个父类。2、我们可以让已经存在的类型满足协议。子类就没那么灵活了，我们无法以追溯的方式去变更 CGContext 的父类。3、协议既可以用于类，也可以用于结构体，而父类就无法和结构体一起使用了。4、最后，当处理协议时，我们无需担心方法重写或者在正确的时间调用super这样的问题。 示例代码理解1、定义协议Drawing（抽象出来的方法集）1234protocol Drawing &#123; mutating func addEllipse(rect: CGRect, fill: UIColor) mutating func addRectangle(rect: CGRect, fill: UIColor)&#125; mutating关键字：使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。 2、CGContext、SVG 遵守协议Drawing，实现协议的方法12345678910extension CGContext: Drawing &#123; func addEllipse(rect: CGRect, fill : UIColor) &#123; setFillColor( fill .cgColor) fillEllipse (in: rect) &#125; func addRectangle(rect: CGRect, fill fillColor : UIColor) &#123; setFillColor(fillColor .cgColor) fill (rect) &#125;&#125; 1234567891011121314151617181920struct SVG &#123; var rootNode = XMLNode(tag: "svg") mutating func append(node: XMLNode) &#123; rootNode.children.append(node) &#125;&#125;extension SVG: Drawing &#123; mutating func addEllipse(rect: CGRect, fill: UIColor) &#123; var attributes: [String:String] = rect.svgAttributes attributes["fill "] = String(hexColor:fill ) append(node: XMLNode(tag: "ellipse", attributes: attributes)) &#125; mutating func addRectangle(rect: CGRect,fill: UIColor) &#123; var attributes: [String:String] = rect.svgAttributes attributes["fill"] = String(hexColor:fill ) append(node: XMLNode(tag: "rect", attributes: attributes)) &#125;&#125; 3、写协议扩展，协议扩展里可以定义完整的方法实现。如果协议扩展里的方法没有声明到定义的协议中就是静态派发，如果也声明到协议中就是动态派发 （也就是协议要求的方法是动态派发的，而仅定义在扩展中 的方法是静态派发的）12345678extension Drawing &#123; mutating func addCircle(center: CGPoint, radius: CGFloat,fill: UIColor) &#123; let diameter = radius/2 let origin = CGPoint(x: center.x - diameter, y: center.y - diameter) let size = CGSize(width: radius, height: radius) let rect = CGRect(origin: origin, size: size) addEllipse(rect: rect, fill : fill ) &#125; &#125; 4、集成了协议的类、结构体、枚举等，他们都能拥有协议扩展里的方法。CGContext、SVG遵守了协议Drawing的话，那么他们也将拥有了addCircle方法。 5、遵守了协议的类、结构体、对象等，他们可以在自己内部重写协议或者协议扩展中的方法，使得功能更具体更接近自己的业务逻辑需求。（如果这时候创建的）1234567891011extension SVG &#123; mutating func addCircle(center: CGPoint, radius: CGFloat,fill: UIColor) &#123; var attributes: [String:String] = [ "cx": "\(center.x)", "cy": "\(center.y)", "r": "\(radius)", ] attributes["fill "] = String(hexColor:fill ) append(node: XMLNode(tag: "circle", attributes: attributes)) &#125; &#125; 6、如果 SVG 不遵守 Drawing 协议的情况下调用addCircle方法，则是调用了的是SVG内重写的addCircle方法123var sample = SVG()sample.addCircle(center: .zero, radius: 20, fill: .red) print (sample) 如果 SVG 遵守了 Drawing 协议的情况下调用addCircle方法，则是调用了的是的协议扩展中的addCircle方法123var sample : Drawing = SVG() //编译器会自动将 SVG 值封装到一个代表协议的类型中，这个封装被称作存在容器sample.addCircle(center: .zero, radius: 20, fill: .red) //静态派发,它总是会使用 Drawing 的扩展。如果它是动态派发，那么它肯定需要将方法的接收者 SVG 类型考虑在内print (sample) 7、将 addCircle 变为动态派发，即把它添加到协议定义里12345protocol Drawing &#123; mutating func addEllipse(rect: CGRect,fill: UIColor) mutating func addRectangle(rect: CGRect,fill: UIColor) mutating func addCircle(center: CGPoint, radius: CGFloat,fill: UIColor)&#125; 我们依旧可以像之前那样提供一个默认的实现。而且和之前一样，具体的类型还是可以自由地重写addCircle。因为现在它是协议定义的一部份了，它将被动态派发。在运行时，根据方法接收者的动态类型的不同，存在容器将会在自定义实现存在时对其进行调用。如果自定义实现不存在，那么它将使用协议扩展中的默认实现。addCircle 方法变为了协议的一个自定义入口。Swift 标准库大量使用了这样的技术。像是Sequence这样的协议有非常多的必要方法，不过几乎所有的方法都有默认实现。因为方法是动态派发的，所以实现Sequence 协议的类型可以自定义默认实现，不过这并不是必须的。 在 Swift 中，协议是非常重要的构建单元。使用协议，我们可以写出灵活的代码，而不必拘泥于接口和实现的耦合。不要过度使用协议。有时候，一个独立的像是结构体或者类的类型要比定义一个协议容易理解得多，简单的类型系统也有利于增加代码的可读性。 使用协议最大的好处在于它们提供了一种最小的实现接口。协议只对某个接口究竟应该做什么进行定义，而把使用多种类型来具体实现这个接口的工作留给我们。同样，这也让测试变得更加容易。我们只需要创建一个满足协议的简单的测试类型就可以开始测试工作了，而不必引入和建立一串复杂的依赖关系。 面向协议编程：1、根据需求功能，抽象出方法，定义协议2、为协议添加对应扩展3、遵守协议，然后满足协议要求的，都能使用协议和协议扩展中的功能方法。声明在协议里的方法是动态派发，而仅定义在扩展中的方法是静态派发的。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可选值]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%8F%AF%E9%80%89%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在编程世界中有一种非常通用的模式，那就是某个操作是否要返回一个有效值。在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言)但是开发中赋值nil,在所难免.因此推出了可选类型可选类型的取值:有值、空值可选值的目的：让代码更严谨 可选值概览1、 定义1234567891011// 定义可选值var name :String?name = "科比"// 1、可选值解包if name != nil &#123; print(name!) //科比&#125;// 2、可选绑定if let str = name &#123; print(str) //科比&#125; 2、应用场景12345678910111213// 将字符串类型转成Int类型let str = "123"let result : Int? = Int(str) // nil/Intprint(result) //Optional(123)// 根据文件名称,读取路径let path : String? = Bundle.main.path(forResource: "123.plist", ofType: nil)print(path) // nil// 从字典中取内容let dict : [String:Any] = ["name":"阿呆","age":18]print(dict["name"]) //Optional("阿呆")print(dict["age"]) //Optional(18) 3、if let当遇到 nil 时终止的循环使用if let来进行可选绑定(optional binding)1234567891011121314151617181920var array = ["one", "two", "three", "four"]if let idx = array.index(of: "four") &#123; array.remove(at: idx)&#125;print(array) //["one", "two", "three"]// if 的可选绑定也可以跟一个布尔限定语句搭配if let idx = array.index(of: "two" ), idx != array.startIndex &#123; array.remove(at: idx)&#125;print(array) //["one", "three"]// 多个 let 的每一部分也能拥有一个布尔值限定的语句let urlString = "http://www.objc.io/logo.png"if let url = URL(string: urlString ), url.pathExtension == "png", let data = try? Data(contentsOf: url), let image = UIImage(data: data)&#123; let view = UIImageView(image: image)&#125; 4、while let当遇到 nil 时终止的循环1234567while let line = readLine(), !line.isEmpty&#123; print ( line )&#125;for i in 0..&lt;10 where i % 2 == 0&#123; print(i)&#125; nil 合并运算符?? 操作符连接的使用默认值的语句，它代表 “这是一个默认值”1、基本使用1234567891011121314151617181920let str = "wda"let num = Int(str) ?? 0print(num) // 0// 数组的 first和last 返回的是可选值let array = [1,2,3]let a = array.first ?? 0print(a) // 1// 通过数组下标取值返回的不是可选值array.count &gt; 5 ? array[5] : 0 // 0// 这时可以给Array写扩展实现extension Array &#123; subscript(safe idx: Int ) -&gt; Element? &#123; return idx &lt; endIndex ? self[idx] : nil &#125;&#125;// 调用扩展array[safe: 5] ?? 0 // 0 2、合并操作也能够进行链接（有多个可选值，并且想要按照顺序选取其中非 nil 的值）123456let i: Int? = nillet j: Int? = nillet k: Int? = 42let m = i ?? j ?? k // 按顺序取，取第一个非nil值print(m) // Optional(42)print(type(of: m)) //Optional&lt;Int&gt; 3、？？和if let的配合使用(可看作是和“or”语句类似) 123if let n = i ?? k &#123; // 和 if i != nil || k != nil 类似 print (n) // 42&#125; 4、而多个if let语句并列则等价于 “and” 123if let _ = i , let _ = j &#123; // 和if i != nil &amp;&amp; j != nil 类似 print("啦啦啦")&#125; 5、双重嵌套的可选值因为可选值是链接的，如果你要处理的是双重嵌套的可选值，并且想要使用 ?? 操作符的话，你 需要特别小心 a ?? b ?? c 和 (a ?? b) ?? c 的区别。前者是合并操作的链接，而后者是先解包 括号内的内容，然后再处理外层:1234let s1: String?? = nil // nil(s1 ?? "inner") ?? "outer" // innerlet s2: String?? = .some(nil) // Optional(nil)(s2 ?? "inner") ?? "outer" // outer 可选值中的map和flatMap1、可选值 map可选值的 map 方法只会操作一个值，那就是该可选值中的那个可能的值,这一点与序列中的map有所不同1234//将字符数组汇总第一个字符转换为字符串let characters: [Character] = ["a", "b", "c"]let rstChar = characters.first.map &#123; String($0) &#125;print(rstChar) // Optional("a") 2、可选值 flatMap (展平可选值)1234567891011121314let stringNumbers = ["1", "2", "3", "foo"]let x = stringNumbers.first.map &#123; Int($0) &#125;print(x)// Optional(Optional(1))//map 返回可选值 (first 可能会是 nil)，Int(String) 也返回可选值 (字符串可能不是一个整数)，最后 x 的结果将会是 Int??// 这时可以使用flatMap把结果展平为单个可选值let y = stringNumbers.first.flatMap &#123; Int($0)&#125;print(y) //Optional(1)//这样 y 就是 Int? 类型// flatMap 和 if let 非常相似if let a = stringNumbers.first, let b = Int(a) &#123; print (b) // 1&#125; 3、使用 map 和 flatMap 来重写多个 if let 的语句12345678let urlString = "http://www.objc.io/logo.png"let view = URL(string: urlString) .flatMap &#123; try? Data(contentsOf: $0) &#125; .flatMap &#123; UIImage(data: $0) &#125; .map &#123; UIImageView(image: $0) &#125;if let view = view &#123; self.liveView = view&#125; 4、使用 flatMap 过滤 nil1234let numbers = ["1", "2", "3", "foo"]let reuslt = numbers.flatMap &#123; Int($0) &#125;.reduce(0, +)print(reuslt) // 6//这里的flatMap的作用：为可选值的序列进行展平 强制解包的时机当你能确定你的某个值不可能是 nil 时可以使用叹号其实你也可以使用source.flatMap { $0 }这个方法替代 ! 改进强制解包的错误信息123456789infix operator !!func !! &lt;T&gt;(wrapped: T?, failureText:@autoclosure() -&gt; String) -&gt; T &#123; if let x = wrapped &#123; return x &#125; fatalError(failureText())&#125;let s = "foo"let w = Int(s) !! "Expecting integer, got \"\(s)\""print(w) //fatal error: Expecting integer, got "foo": file MyText.playground, line 10 在调试版本中进行断言在调试时触发断言，但是在发布版本中打印 01234567891011let s = "rt"infix operator !?func !?&lt;T: ExpressibleByIntegerLiteral&gt; (wrapped: T?, failureText: @autoclosure () -&gt; String) -&gt; T&#123; assert(wrapped != nil, failureText ()) return wrapped ?? 0&#125;let i = Int(s) !? "Expecting integer, got \"\(s)\""print(i) //assertion failed: Expecting integer, got "rt": file MyText.playground, line 22]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组变形]]></title>
    <url>%2F2017%2F09%2F29%2F%E6%95%B0%E7%BB%84%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 一、Map 转换let arr1 = [0,1,2,3,5]let result1 = arr1.map &#123;$0 * $0&#125;print(result1) // [0, 1, 4, 9, 25]// 二、FlatMaplet arr2 = [[1,2,3],[4,5,6]];let res = arr2.map &#123; $0.map&#123; $0 + 2 &#125; &#125;print(res) // [[3, 4, 5], [6, 7, 8]]var flatRes = arr2.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;print(flatRes) // [3, 4, 5, 6, 7, 8]// 三、Fliter 过滤let arr3 = [0,1,2,3,4,5,6,7,8,9,10]let result3 = arr3.filter &#123;$0 % 2 == 0&#125;print(result3) //[0, 2, 4, 6, 8, 10]//map和fliter组合使用，寻找 100 以内同时满足是偶数并且是其他数字的 平方的数let result31 = (1..&lt;10).map &#123; $0 * $0 &#125;.filter &#123; $0 % 2 == 0 &#125;print(result31) // [4, 16, 36, 64]// 四、Reduce 合并let arr4 = [0,1,2,3,5]let result4 = arr4.reduce(0,+)print(result4) //11// 五、Zip 是将两个序列的元素，一一对应合并成元组，生成一个新序列let a = [1, 2, 3, 4]let b = ["a", "b", "c", "d", "e"]let c = zip(a, b).map &#123; $0 &#125;print(c) // [(1, "a"), (2, "b"), (3, "c"), (4, "d")]/*zip 生成的序列通常会进行下一步处理。比如func loadColors(colors: [UIColor]) &#123; zip(self.colorButtons, colors).forEach &#123; (bt, color) in bt.color = color &#125;&#125;*/// zip和速记+来通过添加两个冲突的值来解析重复的键let keyNames2 = ["a", "b", "c", "a", "b"]let dict = Dictionary(zip(keyNames2, repeatElement(1, count: keyNames2.count)), uniquingKeysWith: +)print(dict) //["b": 2, "a": 2, "c": 1]// 六、 ForEach 跟for类型，forEach不返回任何值（有return的时候，使用for比forEach比较好）//theViews.forEach(view.addSubview)// 七、其它/* $0代表传入的元素本身，而不是下标 $0.0代表传入的元组的第一个值，如果元组被命名过了，则可以直接带名字 $0.age代表传入的模型的age属性 // 年龄升序排列 people.sort &#123; $0.age &lt; $1.age &#125; // 检查是否有小于18岁的 people.contains &#123; $0.age &lt; 18 &#125; // 忽略大小写的排序 people.sort &#123; $0.name.uppercased() &lt; $1.name.uppercased() &#125; */]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拥抱Swift]]></title>
    <url>%2F2017%2F09%2F27%2F%E6%8B%A5%E6%8A%B1Swift%2F</url>
    <content type="text"><![CDATA[随着秋季发布会过后Swift4也正式放出，Switf4已趋向于稳健，为Swift3提供了源码兼容。无论是旧OC项目慢慢迁移到Swift4还是新项目直接使用Swift4，时机已然成熟，让我们拥抱Swift吧。Swift的灵活与优雅真让人神往。 Swift 既是一⻔高层级语言，又是一⻔低层级语言。 你可以在 Swift 中用 map 或者 reduce 来 写出十分类似于 Ruby 和 Python 的代码，你也可以很容易地创建自己的高阶函数。Swift 让你有能力快速完成代码编写，并将它们直接编译为原生的二进制可执行文件，这使得性能上可以与C 代码编写的程序相媲美。我们可以兼顾高低两个层级。将一个数组通过闭包表 达式映射到另一个数组所编译得到的汇编码，与直接对一块连续内存进行循环所得到的结果是一致的。Swift 是一⻔多范式的语言。你可以用 Swift 来编写类似于OC语言那样面向对象的代码，也可以使用不变量的值来写纯函数式的程序。 Swift 拥有泛型，协议，协议扩展，值类型以及闭包等特性，这些特性是对函数式⻛格的很好的介绍。 如果一个函数接受别的函数作为参数，或者一个函数的返回值是函数，那么这样的函数就叫做高阶函数(higher-order function)。 定义在类或者协议中的函数就是方法 (method)自由函数和那些在结构体上调用的方法是静态派发 (statically dispatched) 的类或者协议上的方法可能是动态派发 (dynamically dispatched) 的。 实现多态（polymorphic）的三种方式：1、子类型和方法重写 (overriding)2、函数重载 (overloading)，它是指为不同的类型多次写同一个函数的行为3、通过泛型，也就是一次性地编写能够接受任意类型的的函数或者方法 优先选择结构体，只在确实需要使用到类特有的特性或者是引用语义时才使用类。尽可能地对现有的类型和协议进行扩展，而不是写一些全局函数。这有助于提高可读性， 让别人更容易发现你的代码 项目Swift化、项目组件化/模块化、非业务组件开源化等技术改造将成为后续的工作]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC与Swift混合编程]]></title>
    <url>%2F2017%2F09%2F26%2FOC%E4%B8%8ESwift%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[OC中使用Swift1、设置DefinesModule为Yes2、把Product Module Name 设置为你的项目工程名字3、编译一下你的项目，再在Objective-C Generated Interface Header Name 中查看是否系统已经帮你生成了XXXX-Swift.h（如果未生成，可以先随意创建一份OC的文件，再编译一下，就能看到这个文件生成了）注意：XXXX-Swift.h这个文件是系统帮你生成的。4、在需要引用到的导入这个头文件即可,这样就可以在OC中调用Swift的了 Swift中使用OC1、当你在Swift项目中尝试创建OC文件时，，系统会弹出一个对话框让你选择是否让系统帮你创建一个XXXXX-Bridging-Header.h的桥接文件，你只需要点Yes即可。假如你错点了其它选项或者没有此对话框，你也可以通过手动创建一个.h文件，文件名随意，但最好还是以XXXXX-Bridging-Header.h这种格式比较规范，然后为这个文件设置对应的路径即可2、你把需要引用的OC头文件添加到XXXXX-Bridging-Header.h这个文件里即可。同理Swift引用第三方OC库也是这样设置的。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift第三方框架]]></title>
    <url>%2F2017%2F09%2F15%2FSwift%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[// 图片加载pod ‘Kingfisher’ // 函数式链式编程pod ‘RxSwift’pod ‘RxCocoa’pod ‘RxDataSources’ // json-&gt;modelpod ‘HandyJSON’ // 布局约束pod ‘SnapKit’ // 网络请求pod ‘Moya/RxSwift’pod ‘Alamofire’ // 日期格式化pod ‘SwiftDate’ // pod ‘Then’ // 表单组件 pod ‘SwiftForms’ // 加密库pod ‘CryptoSwift’]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveSwift示例]]></title>
    <url>%2F2017%2F09%2F13%2FReactiveSwift%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1、UIButton监听点击123btn.reactive.controlEvents(.touchUpInside).observeValues &#123; (btn) in print("点到我了")&#125; 2、UItextfield监听123456789101112131415161718 // 监听tf的输入值tf.reactive.continuousTextValues.observeValues &#123; (text) in print(text ?? "")&#125;// 监听tf的输入长度tf.reactive.continuousTextValues.map &#123; (text) -&gt; Int in return text!.characters.count&#125;.observeValues &#123; (count) in print(count)&#125;// 当输入字符长度大于3时，才会接收到信息tf.reactive.continuousTextValues.filter &#123; (text) -&gt; Bool in return text!.characters.count&gt;3&#125;.observeValues &#123; (text) in print(text ?? "")&#125; 3、监听UIViewController的viewWillAppear方法123self.reactive.trigger(for: #selector(UIViewController.viewWillAppear(_:))).observeValues &#123; () in print("viewWillAppear被调用了哦")&#125; 4、在OneVC里，监听TwoVC的deinit12345let twoVC = TwoVC()twoVC.reactive.lifetime.ended.observeCompleted &#123; print("textVC已成功销毁")&#125;navigationController?.pushViewController(twoVC, animated: true) 5、RAC替换代理1234// 监听_redView有没有调用btnClick:,如果调用了就会转换成信号[[_redView rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123; NSLog(@"控制器知道,点击了红色的view");&#125;]; 6、KVO123456789@property (nonatomic, assign) int age;// 把监听到内容转换成信号[[self rac_valuesForKeyPath:@"age" observer:nil] subscribeNext:^(id x) &#123; // block:只要属性改变就会调用,并且把改变的值传递给你 NSLog(@"%@",x);&#125;];- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.age++;&#125; 7、监听通知1234// 只要发出这个通知,又会转换成一个信号[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@"弹出键盘");&#125;];]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播试炼]]></title>
    <url>%2F2017%2F09%2F10%2F%E7%9B%B4%E6%92%AD%E8%AF%95%E7%82%BC%2F</url>
    <content type="text"><![CDATA[直播APP主要实现的流程1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动 直播APP架构 直播APP技术点 已有框架的支撑1、视频采集端LFLiveKit：一个OC写的可读性非常好的开源推流框架 2、视频处理框架GPUImage：一个基于OpenGL ES的一个强大的图像/视频处理框架,封装好了各种滤镜同时也可以编写自定义的滤镜,其本身内置了多达120多种常见的滤镜效果。 美颜功能也可以直接使用的是BeautifyFace，它可以很快速的实现美颜功能，效果不错，它的底层还是基于的GPUImage 3、视频播放端ijkplayer:一个基于FFmpeg的开源Android/iOS视频播放器把ijkplayer编译成对应使用的平台，最好把IJKMediaPlayer打包成静态库，然后倒入到项目中，有直播的拉流地址就可以播放啦映客主播url:http://116.211.167.106/api/live/aggregation?uid=133825214&amp;interest=1 FFmpeg：是一个跨平台的开源视频框架,能实现如视频编码,解码,转码,串流,播放等丰富的功能。其支持的视频格式以及播放协议非常丰富,几乎包含了所有音视频编解码、封装格式以及播放协议。 4、配置流媒体服务器尝试在Mac上搭建nginx+rtmp服务器nginx:免费开源web服务器，用它来做hls或者rtmp流媒体服务器是非常不错 5、聊天互动使用网易云信、腾讯云、融云等第三方SDK]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS项目架构概述]]></title>
    <url>%2F2017%2F09%2F10%2FiOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[基于业务需求的架构，不要为了架构而架构 MVCMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写是 苹果官方文档 推荐使用的一个设计模式，经典中的经典。看懂斯坦福公开课上的这张图就够了 控制器可以直接访问模型数据，控制器通过懒加载数据，再把数据给view展示。 M只负责提供数据，不关心数据展示在哪里； V展示什么数据，只有C知道，V是通过C的数据源来获得数据； 为了保持M和V的重用性，M和V都不能直接拥有C； M和V不能相互访问，M不知道V的存在，V不知道M的存在，他们2个只能通过C建立联系。 特点：简单明了够清晰。加上写分类，抽取工具类，按需抽取业务managerMVC是一个非常成熟的架构，在业务开始复杂的时候，合理的将网络请求，数据持久化等相关与控制器耦合不严重的公共抽取出来，足够满足日常开发需求。例如：网络请求数据，可以先对AFN框架进行通用基础封装，再进行业务层封装，使用block回调数据。 MVVM从广义上讲，MVVM也属于MVC的编程思想范畴，它是把业务逻辑抽取成一个VM模块，减轻C的压力，弱化C，以便于重用和测试，且兼容MVC MVVM With RACReactiveCocoa简称RAC，是由Github开源的一个应用于iOS和OS开发的新框架。RAC吸纳了函数式编程(Funtional Programming)和响应式编程(Reactive Programing)的编程思想，它也被描述为函数响应式编程（FRP）框架。RAC最大的优点是 提供了一个单一的、统一的方法去处理异步的行为，包括 Delegate，Blocks Callbacks，Target-Action机制，Notifications和KVO。它最大的与众不同是提供了一种新的写代码的思维，由于RAC将Cocoa中KVO、UIKit Event、Delegate、Selector等都增加了RAC支持，所以都不用去做很多跨函数的事，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。。参考学习：最快让你上手ReactiveCocoa之基础篇最快让你上手ReactiveCocoa之进阶篇美团点评技术团队的博文 MVVM With RxSwiftRxSwift是整个ReactiveX里针对Swift语言的库，ReactiveX里面还有针对Java，JS，.Net, Swift，Android，PHP等使用的库，它们内部都用了ReactiveX的逻辑思想。 ReactiveX是Reactive Extensions的缩写，一般简写为Rx。Rx(函数库) = Observables(异步数据流) + LINQ(操作符查询异步数据流) + Schedulers(参数化异步数据流的并发处理)。Rx是一种编程模型，最初由微软开发，结合了观察者模式、迭代器模式和函数式编程的精华，来更方便地处理异步数据流。其中最重要的一个概念是 Observable。Rx提供了观察者模式来处理事件序列，还提供了很多强大的操作符，操作符让你可以变换、组合、操纵和处理Observable发射的数据；让你可以用声明式的风格组合异步操作序列，它拥有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。 RxSwift 也被描述为函数响应式编程(Functional Reactive Programming, FRP)框架。推荐参考学习：RxSwiftwhy use rx?Marbles使用 RxSwift 进行响应式编程是时候学习 RxSwift 了坠入链式编程的幻乐里–用RxSwift仿写知乎日报RxSwift/Documentation/的中文翻译ReactiveX文档中文翻译 可以尝试Moya+RxSwift+HandyJSON这几个框架一起使用。其实RAC和RxSwift都能实现函数式响应式编程，满足你的开发编码需求。如果是使用OC的项目可以使用RAC，Swift项目可以使用RxSwift。个人还是比较喜欢RxSwift，因为其文档写得更清晰优秀，且相对来说比较轻量级，语法更新比较少，RAC后期也是吸纳了一些Rx的思想。 VIPER含义：视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing)其实可以简单的理解为MVC里抽取多了两部分：把MC之间交互的部分抽取成一个DataTool，用于处理网络请求、数据解析把MV之间的逻辑部分抽取成Presenter，用于准备所有View需要的最终数据，展示到view上面 组件化方案参阅：iOS项目组件化开发 其它单向数据流动的函数式 View ControllerRxSwiftReSwiftReSwift介绍]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播小总结]]></title>
    <url>%2F2017%2F09%2F08%2F%E7%9B%B4%E6%92%AD%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今年接触了一个秀场直播项目，在此做一下简单小总结。 一、功能介绍1、直播列表：关注、热门、明星、同城等等2、排行榜：贡献榜、财富榜3、商城：商品展示、购物车，订单地址管理、订单状态、支付宝微信支付4、直播端：录制、推流、美颜、背景音乐、分享，主播对观众的禁言、拉黑、设置管理员等5、观看端：单聊、聊天室、私聊、@TA,点亮爱心，举报、个人名片、个人主页等6、礼物：普通礼物、特效礼物、实体礼物、充值、提现、内购等7、用户逻辑：手机账号注册登陆、第三方账号登录、个人信息编辑、设置管理、直播回看、关注列表、粉丝列表、我的收益、我的礼物、等级、认证等8、管理后台：审核、禁播等等 二、架构1、使用最经典的MVC架构。（MVC是一个非常成熟的架构，在业务开始复杂的时候，合理的将网络请求，数据持久化等相关与控制器耦合不严重的公共抽取出来，足够满足日常开发需求）出于公司团队型项目协作的考虑、新老接替能因素，使用最稳成熟的MVC2、部分业务逻辑采用抽取manager来管理（比如：收发信息、请求发送礼物、礼物动画）3、网络请求业务，先对AFN框架进行通用基础封装，再进行业务层封装，使用block回调数据。4、项目结构图简图待续… 功能实现待续… 部分业务思路流程待续…]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIBezierPath]]></title>
    <url>%2F2017%2F08%2F19%2FUIBezierPath%2F</url>
    <content type="text"><![CDATA[使用UIBezierPath类可以创建基于矢量的路径，这个类在UIKit中。此类是Core Graphics框架关于path的一个封装。使用此类可以定义简单的形状，如椭圆或者矩形，或者有多个直线和曲线段组成的形状。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class BezierPathView: UIView &#123; override func draw(_ rect: CGRect) &#123; // 画矩形 let bp = UIBezierPath(rect:CGRect(x: 10, y: 30, width: 30, height: 50)) UIColor.green.set() bp.fill() // 画椭圆(如果宽高相等则为圆) let ovel = UIBezierPath(ovalIn: CGRect(x: 50, y: 30, width: 60, height: 40)) UIColor.red.set() ovel.fill() // 画圆角的矩形（圆角值为8） let roundeRect1 = UIBezierPath(roundedRect: CGRect(x: 120, y: 30, width: 60, height: 40), cornerRadius: 8) UIColor.orange.set() roundeRect1.fill() // 画矩形，指定某个或多个角设置圆角 let roundeRect2 = UIBezierPath(roundedRect: CGRect(x: 190, y: 30, width: 60, height: 40), byRoundingCorners: [.topLeft,.bottomRight], cornerRadii: CGSize(width: 20, height: 60)) UIColor.blue.set() roundeRect2.fill() // 画圆弧1 let arcPath = UIBezierPath(arcCenter: CGPoint(x: 50, y: 120), radius: 40, startAngle:2 * .pi, endAngle: .pi/2, clockwise: true) UIColor.brown.set() arcPath.stroke() // 画圆弧2 let arcPath2 = UIBezierPath() arcPath2.addArc(withCenter: CGPoint(x: 250, y: 120), radius: 40, startAngle: .pi, endAngle: .pi * 2, clockwise: false) arcPath2.stroke() // 二阶贝赛尔曲线(起点、终点、一个控制点) let twoPath = UIBezierPath() twoPath.move(to: CGPoint(x: 20, y: 250)) twoPath.addQuadCurve(to: CGPoint(x: 100, y: 250), controlPoint: CGPoint(x: 80, y: 180)) let twoPath1 = UIBezierPath() twoPath1.move(to: CGPoint(x: 150, y: 250)) twoPath1.addQuadCurve(to: CGPoint(x: 230, y: 250), controlPoint: CGPoint(x: 190, y: 180)) twoPath1.append(twoPath) //拼接路径 UIColor.black.set() twoPath1.lineWidth = 2.0 twoPath1.lineCapStyle = .square twoPath1.lineJoinStyle = .round twoPath1.stroke() // 三阶贝赛尔曲线(起点、终点、两个控制点) let threePath = UIBezierPath() threePath.move(to: CGPoint(x: 20, y: 350)) threePath.addCurve(to: CGPoint(x: 300, y: 350), controlPoint1: CGPoint(x: 100, y: 250), controlPoint2: CGPoint(x: 180, y: 450)) UIColor.orange.set() threePath.stroke() &#125;&#125; 圆弧起始点二阶贝塞尔曲线示意图三阶贝塞尔曲线示意图]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz2D]]></title>
    <url>%2F2017%2F08%2F18%2FQuartz2D%2F</url>
    <content type="text"><![CDATA[Quartz 2D是一个二维图形绘制引擎，我们可以使用Quartz 2D 实现基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。在需要的时候，Quartz 2D还可以借助图形硬件的功能。 一、自定义View利用Quartz 2D绘制东西到View上，首先要有图形上下文用于保存绘图信息，再把内容绘制到View上。自定义View的步骤：1、新建一个继承自UIView的类；2、实现- (void)drawRect:(CGRect)rect方法，在这个方法中实现自定义； 获取跟当前View想关联的图形上下文 绘制相应的图形内容 利用图形上下文将绘制的所有内容渲染显示到View上面123456789// 当view第一次显示的时候调用,rect == self.bounds,该方法不能手动调用,只能让系统自动调用- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 获得图形上下文 CGContextAddRect(ctx, CGRectMake(100, 100, 200, 200)); //绘制矩形 // CGContextSetRGBStrokeColor(ctx, 0, 1, 0, 1.0);// 边界颜色 CGContextSetRGBFillColor(ctx, 0, 1, 0, 1); //填充颜色 // CGContextStrokePath(ctx);// 渲染边界 CGContextFillPath(ctx); // 渲染填充&#125; 二、基础绘图第一步：获得图形上下文CGContextRef ctx = UIGraphicsGetCurrentContext();第二步：设置图形信息、图形状态第三步：把图形信息渲染到View上CGContextStrokePath(ctx); 边界CGContextFillPath(ctx); 填充CGContextDrawPath(ctx, kCGPathFillStroke); 边界和填充绘制线条只能以边界形式绘制,不能填充 1、绘制线条1234567891011CGContextRef ctx = UIGraphicsGetCurrentContext();// 绘制第一条线CGContextMoveToPoint(ctx, 100, 100); //设置起点CGContextAddLineToPoint(ctx, 200, 200); //添加一条直线到终点CGContextSetLineWidth(ctx, 10); // 设置线条宽度CGContextSetRGBStrokeColor(ctx, 1.0, 0, 0, 1.0); // 设置线条颜色CGContextSetLineCap(ctx, kCGLineCapRound); // 设置线条两端样式（加帽子）// 绘制第二条线CGContextAddLineToPoint(ctx, 300, 50); // 该方法会自动连接上一条线的终点CGContextSetLineJoin(ctx, kCGLineJoinRound); // 设置线条转折点样式CGContextStrokePath(ctx); 2、绘制三角形1234567891011121314CGContextRef ctx = UIGraphicsGetCurrentContext();// 第一条线CGContextMoveToPoint(ctx, 100, 100);CGContextAddLineToPoint(ctx, 200, 200);CGContextSetLineWidth(ctx, 10); CGContextSetRGBStrokeColor(ctx, 1.0, 0, 0, 1.0); CGContextSetLineCap(ctx, kCGLineCapRound); // 绘制第二条线CGContextAddLineToPoint(ctx, 300, 50);CGContextSetLineJoin(ctx, kCGLineJoinRound);// 绘制第三条线// CGContextAddLineToPoint(ctx, 100, 100);// 该方法会自动连接上一条线的终点CGContextClosePath(ctx);// 该方法会自动连接起点和终点CGContextStrokePath(ctx); 3、绘制圆、圆弧1234567CGContextRef ctx = UIGraphicsGetCurrentContext();// CGContextAddEllipseInRect(ctx, CGRectMake(10, 10, 100, 100)); // 圆CGContextAddEllipseInRect(ctx, CGRectMake(10, 10, 150, 100)); // 椭圆// [[UIColor yellowColor] set]; // 统一设置颜色[[UIColor yellowColor] setFill]; // 设置填充颜色[[UIColor redColor] setStroke]; // 设置边界颜色CGContextDrawPath(ctx, kCGPathFillStroke); 绘制弧的方法坐标是以X轴的正坐标方向为角度0开始计算 c 当前图形上下文 x 圆心的x值 y 圆心的y值 radius 半径 startAngle 开始角度 endAngle 结束角度 clockwise 绘制方向:0:表示顺时针,1:表示逆时针CGContextAddArc(CGContextRef _Nullable c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)12345CGContextRef ctx = UIGraphicsGetCurrentContext();CGFloat centerX = rect.size.width * 0.5;CGFloat centerY = rect.size.height * 0.5;CGContextAddArc(ctx, centerX, centerY, 50, 0 , 2 * M_PI , 0); CGContextStrokePath(ctx); 4、绘制图片123456- (void)drawRect:(CGRect)rect &#123; UIImage * img = [UIImage imageNamed:@"girl.png"]; [img drawInRect:rect]; // 拉伸填充&#125;[img drawAsPatternInRect:rect]; 平铺[img drawAtPoint:CGPointMake(20, 20)];指定绘制起点坐标 5、绘制文字1234567NSString *str = @"好学若饥，谦卑若愚";[str drawInRect:CGRectMake(10, 10, 50, 50) withAttributes:nil];//指定文字显示区域// withAttributes 这个参数可以设置一个富文本的字典// NSDictionary *dic = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:20],// NSForegroundColorAttributeName: [UIColor blueColor]&#125;;//[str drawAtPoint:CGPointMake(10, 10) withAttributes:dic];//指定起始位置显示文字 6、图形上下文栈主要作用：备份保存，相当于还原上下文初始状态，不用手动复原。 当需要连续绘制多个不同样式的图形在一起的时候，在设置当前绘图信息和绘图状态之前，保存一份图形上下文到栈区，在绘制下一个图形时，把刚才保存的那个图形上下文出栈，相当于你得到了上一个图形上下文的初始状态。 图形上下文的保存和出栈都是成对出现的。CGContextSaveGState(ctx); // 将当前图型上下文保存到一个栈里面CGContextRestoreGState(ctx); // 将图形上下文出栈 7、矩阵操作我们知道利用transform属性的旋转、平移、缩放等默认都是以中心点为基准点的。而在图形上下文中默认是以0，0点作为基准点。123456789101112CGContextRef ctx = UIGraphicsGetCurrentContext(); [[UIColor redColor] set];CGContextAddRect(ctx, CGRectMake(50, 50, 100, 100));//没缩放的红色矩形作为参照物CGContextStrokePath(ctx);[[UIColor blueColor] set];CGContextScaleCTM(ctx, 0.5, 0.5); //矩阵里的缩放// CGContextTranslateCTM(ctx, 100, 0); // 矩阵里的平移，向X坐标平移100CGContextAddRect(ctx, CGRectMake(50, 50, 100, 100));//蓝色矩形是经过矩阵操作后的矩形CGContextStrokePath(ctx); 矩阵操作里的旋转则相对难理解一点。可以通过先平移、再旋转、再上移来达到效果例如：实现旋转45度CGContextTranslateCTM(ctx, rect.size.width 0.5, rect.size.height 0.5);CGContextRotateCTM(ctx, M_PI_4);CGContextTranslateCTM(ctx, -rect.size.width 0.5, -rect.size.height 0.5); 三、绘图的三种方式1、直接图形上下文绘制1234- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextFillRect(ctx, CGRectMake(30,30, 200, 200));&#125; 2、通过创建path,每一个图形对应一个绘图路径，优点是会比较清晰，增加可读性，缺点是代码多一些1234567891011- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 拼接路径 CGMutablePathRef path1 = CGPathCreateMutable(); CGPathAddEllipseInRect(path1, NULL, CGRectMake(30,30, 200, 200)); CGContextAddPath(ctx, path1); [[UIColor redColor] set]; CGContextStrokePath(ctx); CGPathRelease(path1); // 销毁路径&#125; 3、通过UIBezierPath绘图12345- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(100, 100, 100, 200)]; [[UIColor redColor] set]; [path fill];&#125; 四、绘图应用1、在自定义View内裁剪图片（1）按照需求设定一个裁剪的封闭图形区域（2）绘制你要裁剪的图片到这个封闭区域内，超出部分会裁剪调。1234567891011121314- (void)drawRect:(CGRect)rect &#123;// 1、先画一个封闭区间的圆CGContextRef ctx = UIGraphicsGetCurrentContext();CGContextAddEllipseInRect(ctx, CGRectMake(30, 200, 200, 200));// 2、必须在渲染之前裁剪,调用该方式时要求当前上下文已经存在一个封闭的图形区域CGContextClip(ctx);// 3、渲染CGContextStrokePath(ctx);// 4、加载图片UIImage *image = [UIImage imageNamed:@"psb.jpeg"];// 设置裁剪的0，0点[image drawAtPoint:CGPointZero];&#125; 按照这个思路你可以裁剪你想要得到的图形图片。 2、脱离- (void)drawRect:(CGRect)rect 方法实现裁剪图片给UIImage做一个分类，实现常用的裁剪圆形头像的小功能12345678910111213141516171819202122232425262728293031323334353637#import "UIImage+Extension.h"@implementation UIImage (Extension)+(instancetype)circleImageWithName:(NSString *)imageName&#123; UIImage *image = [UIImage imageNamed:imageName]; UIGraphicsBeginImageContext(image.size);// 创建图形上下文 CGContextRef ctx =UIGraphicsGetCurrentContext(); CGContextAddEllipseInRect(ctx, CGRectMake(0, 0, image.size.width, image.size.height)); // 绘制圆 CGContextClip(ctx); [image drawAtPoint:CGPointZero]; // 绘制图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();// 获得图片 UIGraphicsEndPDFContext(); // 关闭图形上下文 return newImage;&#125;+(instancetype)circleImageWithName:(NSString *)imageName borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)borderColor&#123; UIImage *image = [UIImage imageNamed:imageName]; CGFloat marginX = borderWidth; CGFloat marginY = marginX; CGFloat contextW = image.size.width + marginX; CGFloat contextH = image.size.height + marginY; // 开启图形上下文 UIGraphicsBeginImageContextWithOptions(CGSizeMake(contextW, contextH), NO, 0.0); // 绘制大圆 CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextAddEllipseInRect(ctx, CGRectMake(0, 0, contextW, contextH)); [borderColor set]; CGContextFillPath(ctx); // 绘制小圆 CGContextAddEllipseInRect(ctx, CGRectMake(marginX * 0.5, marginY * 0.5, image.size.width, image.size.height)); CGContextClip(ctx); // 绘制图片 [image drawAtPoint:CGPointMake(marginX * 0.5, marginY * 0.5)]; // 从当前上下文获得图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 关闭上下文 UIGraphicsEndImageContext(); return newImage;&#125; 3、通过赋值属性改变绘制圆的大小123456789101112131415- (void)awakeFromNib &#123; [super awakeFromNib]; self.radius = 10;//设置初始圆的半径&#125;- (void)setRadius:(CGFloat)radius &#123; _radius = radius; [self setNeedsDisplay];//间接调用drawRect方法，重新绘制图画&#125;- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGFloat x = rect.size.width * 0.5; CGFloat y = rect.size.height * 0.5; CGContextAddArc(ctx,x, y, self.radius, 0, M_PI * 2, 0); CGContextFillPath(ctx);&#125; 4、简单的雪花飘落12345678910111213141516171819- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super initWithCoder:aDecoder]) &#123; CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateImage)]; link.frameInterval = 2.0; // 60 / 2 =30次 [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes]; &#125; return self;&#125;- (void)updateImage&#123; self.y += 5; [self setNeedsDisplay];&#125;- (void)drawRect:(CGRect)rect &#123; if (self.y &gt; rect.size.height) &#123; self.y = 0 ; &#125; UIImage *image = [UIImage imageNamed:@"snow"]; [image drawAtPoint:CGPointMake(10, self.y)];&#125; 5、截屏截图123456789101112// 延迟1s截屏dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 1.开启图形上下文 UIGraphicsBeginImageContext(self.view.frame.size); // 2.将控制器view的内容渲染到上下文中 [self.view.layer renderInContext:UIGraphicsGetCurrentContext()]; // 3.从图形上下文中获得图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); NSData *imageData = UIImagePNGRepresentation(newImage); [imageData writeToFile:@"/Users/apple/desktop/abc.png" atomically:YES];&#125;); 6、制作水印图1234567891011121314151617181920UIImage *image = [UIImage imageNamed:@"bgImg.png"];UIImage *logoImage = [UIImage imageNamed:@"logo.png"];CGFloat margin = 10;// 1.开启上下文UIGraphicsBeginImageContext(CGSizeMake(375, 400));// 1.1 绘制背景图[image drawInRect:CGRectMake(0, 0, 375, 400)];// 1.2 绘制logo[logoImage drawAtPoint:CGPointMake(self.view.frame.size.width - margin - logoImage.size.width, margin)]; // 1.2 绘制文字 // NSString *str = @"XX公司程序员"; // NSMutableDictionary *dict = [NSMutableDictionary dictionary]; // dict[NSFontAttributeName] = [UIFont systemFontOfSize:20]; // [str drawAtPoint:CGPointMake(151, 100) withAttributes:dict];// 2.获得图片UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();// 3.关闭上下文UIGraphicsEndImageContext();]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime]]></title>
    <url>%2F2017%2F08%2F17%2Fruntime%2F</url>
    <content type="text"><![CDATA[runtime是一套底层的C语言API（包含很多强大实用的C语言数据类型、C语言函数）运行时最主要的消息机制，是使用c语言给对象发送消息,对象接收到消息后, 找到匹配的方法执行。 常见的函数、头文件123456#import &lt;objc/runtime.h&gt; : 成员变量、类、方法Ivar * class_copyIvarList : 获得某个类内部的所有成员变量Method * class_copyMethodList : 获得某个类内部的所有方法Method class_getInstanceMethod : 获得某个实例方法Method class_getClassMethod : 获得某个类方法method_exchangeImplementations : 交换2个方法的具体实现 应用场景1：字典转模型1234567891011121314151617NSDictionary *dict =@&#123;@"name":@"普京",@"age":@18,@"score":@59&#125;;// 1、搜索类里的成员变量unsigned int count = 0;// 获取这个类所有的成员变量Ivar *Ivars = class_copyIvarList([XRPerson class], &amp;count);XRPerson *person = [[XRPerson alloc]init];for (int i = 0; i&lt;count; i++) &#123; Ivar ivar =Ivars[i]; const char *type =ivar_getTypeEncoding(ivar);//获取成员变量的类型，这里没用到 const char *name = ivar_getName(ivar);// 2、C语言转OC，去掉成员变量的下划线"_" NSMutableString *strM =[[NSMutableString alloc]initWithString:[NSString stringWithUTF8String:name]]; NSString *resultStr =[strM substringFromIndex:1];// 3、通过KVC为成员变量赋值 [person setValue:dict[resultStr] forKey:resultStr];&#125;NSLog(@"%@ %d %.2lf",person.name,person.age,person.score); 应用场景2：归档解档当你想把某个类里的所有成员变量拿出来做一些事情，或者成员变量非常多，你就可以利用运行时一次性的对这个类的所有成员变量进行归档解档。12345678910- (void)encodeWithCoder:(NSCoder *)encoder&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([XRPerson class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; Ivar ivar = ivars[i]; const char *name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; [encoder encodeObject:[self valueForKeyPath:key] forKey:key]; &#125;&#125; 应用场景3：交换2个方法的实现（Method Swizzle）每个类都维护一个方法（Method）列表，Method则包含SEL和其对应IMP的信息，方法交换做的事情就是把SEL和IMP的对应关系断开，并和新的IMP生成对应关系。method_exchangeImplementations 交换2个方法的中的实现class_replaceMethod 修改类method_setImplementation 直接设置某个方法的实现class_getInstanceMethod 获取通过SEL获取一个方法method_getTypeEncoding 获取一个OC实现的编码类型class_addMethod 給方法添加实现 1、当你想对系统的方法做一些手脚，添加或者修改些什么的时候，就可以用runtime交换2方法的实现 2、旧项目用的是imageNamed方法通过简单判断来适配图片的，图片多了，重复代码很垃圾，难更改，难维护。解决方案：利用运行时交换两个方法的实现。写一个image分类，用分类写的方法与系统的方法实现交换了。123456789101112131415161718192021#import &lt;objc/runtime.h&gt;@implementation UIImage (Extension)+(void)load&#123; // 只要分类被装载到内存中，就会调用1次 Method originMethod = class_getClassMethod(self, @selector(imageNamed:)); Method otherMethod = class_getClassMethod(self, @selector(imageWithName:));// 交换2个方法的实现 method_exchangeImplementations(originMethod, otherMethod);&#125;+(UIImage *)imageWithName:(NSString *)name&#123; BOOL iOS8 = [[UIDevice currentDevice].systemVersion floatValue]&gt;=8.0; UIImage *image =nil; if (iOS8) &#123; NSString *newName=[name stringByAppendingString:@"_os8"]; image=[UIImage imageWithName:newName]; &#125; if (image==nil) &#123; image =[UIImage imageWithName:name]; &#125; return image;&#125; 4、屏蔽数组传nil报错,数组越界报错（负面效果是难找到报错，谨慎实用，看场合，权衡使用）解决方案：利用运行时的交换方法的实现的办法（1）只要外面传nil，我在内部就不管它，（2）或者自己打印出来哪里传了nil，这样我们就能发现错在哪，要不然找不到报错的地方。（3）还可以在里面做一些自己想做的事，过滤一些东西，比如：只有传的是string类型的，我才添加到数组中。 5、屏蔽字典传空错误 注意：多个有继承关系的类对象swizzle时，先从父对象开始，这样才能保证子类方法拿到父类中的被swizzle的实现。在+（viod）load中swizzle不会出错，就是因为load类方法会默认从父类开始调用。]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView动画]]></title>
    <url>%2F2017%2F08%2F17%2FUIView%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[UIView动画实质上是对Core Animation的封装，提供简洁的动画接口。对于简单的应用场景，使用UIView动画非常方便简洁。 一、基础动画12345678[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 delay:(NSTimeInterval) //动画延迟执行的时间 options:(UIViewAnimationOptions) //动画的过渡效果 animations:^&#123; //执行的动画 &#125; completion:^(BOOL finished) &#123; //动画执行完毕后的操作 &#125;]; UIViewAnimationOptions的枚举值如下，可组合使用：123456789101112131415161718192021222324UIViewAnimationOptionLayoutSubviews //进行动画时布局子控件 UIViewAnimationOptionAllowUserInteraction //进行动画时允许用户交互 UIViewAnimationOptionBeginFromCurrentState //从当前状态开始动画 UIViewAnimationOptionRepeat //无限重复执行动画 UIViewAnimationOptionAutoreverse //执行动画回路 UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置 UIViewAnimationOptionOverrideInheritedCurve //忽略嵌套动画的曲线设置 UIViewAnimationOptionAllowAnimatedContent //转场：进行动画时重绘视图 UIViewAnimationOptionShowHideTransitionViews //转场：移除（添加和移除图层的）动画效果 UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置 UIViewAnimationOptionCurveEaseInOut //时间曲线，慢进慢出（默认值） UIViewAnimationOptionCurveEaseIn //时间曲线，慢进 UIViewAnimationOptionCurveEaseOut //时间曲线，慢出 UIViewAnimationOptionCurveLinear //时间曲线，匀速 UIViewAnimationOptionTransitionNone //转场，不使用动画 UIViewAnimationOptionTransitionFlipFromLeft //转场，从左向右旋转翻页 UIViewAnimationOptionTransitionFlipFromRight //转场，从右向左旋转翻页 UIViewAnimationOptionTransitionCurlUp //转场，下往上卷曲翻页 UIViewAnimationOptionTransitionCurlDown //转场，从上往下卷曲翻页 UIViewAnimationOptionTransitionCrossDissolve //转场，交叉消失和出现 UIViewAnimationOptionTransitionFlipFromTop //转场，从上向下旋转翻页 UIViewAnimationOptionTransitionFlipFromBottom //转场，从下向上旋转翻页 二、Spring动画1234567891011[UIView animateWithDuration:(NSTimeInterval) delay:(NSTimeInterval) usingSpringWithDamping:(CGFloat)//震动效果，范围0~1，数值越小震动效果越明显 initialSpringVelocity:(CGFloat)//初始速度，数值越大初始速度越快 options:(UIViewAnimationOptions) animations:^&#123; &#125; completion:^(BOOL finished) &#123; &#125;]; 三、Keyframes动画只支持属性关键帧，不支持路径关键帧123456789[UIView animateKeyframesWithDuration:(NSTimeInterval) delay:(NSTimeInterval) options:(UIViewKeyframeAnimationOptions) animations:^&#123; //执行的关键帧动画 &#125; completion:^(BOOL finished) &#123; &#125;]; 增加关键帧的方法：12345[UIView addKeyframeWithRelativeStartTime:(double)//动画开始的时间（占总时间的比例） relativeDuration:(double) //动画持续时间（占总时间的比例） animations:^&#123; //执行的动画 &#125;]; UIViewKeyframeAnimationOptions的枚举值如下，可组合使用：12345678910111213UIViewAnimationOptionLayoutSubviews //进行动画时布局子控件UIViewAnimationOptionAllowUserInteraction //进行动画时允许用户交互UIViewAnimationOptionBeginFromCurrentState //从当前状态开始动画UIViewAnimationOptionRepeat //无限重复执行动画UIViewAnimationOptionAutoreverse //执行动画回路UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置UIViewKeyframeAnimationOptionCalculationModeLinear //运算模式 :连续UIViewKeyframeAnimationOptionCalculationModeDiscrete //运算模式 :离散UIViewKeyframeAnimationOptionCalculationModePaced //运算模式 :均匀执行UIViewKeyframeAnimationOptionCalculationModeCubic //运算模式 :平滑UIViewKeyframeAnimationOptionCalculationModeCubicPaced //运算模式 :平滑均匀 四、转场动画1、单个视图的过渡效果123456789[UIView transitionWithView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) animations:^&#123; &#125; completion:^(BOOL finished) &#123; &#125;]; 2、从旧视图转场到新视图的动画效果1234567[UIView transitionFromView:(nonnull UIView *) toView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) completion:^(BOOL finished) &#123; &#125;]; // toView added to fromView.superview, fromView removed from its superview 五、UIImageView设置图片帧动画123456789// _afterWheel 是一个UIImageViewNSMutableArray* after = [NSMutableArray array];for(int i = 1;i&lt;4;i++)&#123; [after addObject: [UIImage imageNamed:[NSString stringWithFormat:@"resource.bundle/%@%d",@"porche-f",i]]];&#125;_afterWheel.animationImages = after;_afterWheel.animationDuration = 0.05;_afterWheel.animationRepeatCount = 0;[_afterWheel startAnimating];]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer]]></title>
    <url>%2F2017%2F08%2F16%2FCALayer%2F</url>
    <content type="text"><![CDATA[如果一个layer是被一个view创建的,那么这个view通常会自动被赋值给这个layer的delegate属性(也就算说这个view就是这个layer的代理)。你不应该改变这种关系。对于你自己创建的layer,你可以赋值一个代理对象用来动态提供layer的内容和执行其他的任务。 如果一个layer已经关联了一个view对象。那么layer的delegate属性必须设置为这个拥有这个layer的view本身。 UIView和CALayer的关系UIView是iOS页面控件的基类，因为UIView直接继承自UIResponder，所以可以响应用户事件，在iOS中创建的每一个UIView都有一个属性layer（CALayer），layer继承自己NSObject，不能响应用户事件，但layer提供了UIView内容的绘制功能，也就是说UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。UIView和CALayer相互依赖，UIView依赖于CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容，UIView可以理解为是CALayer的高级封装。 一、基础使用1234567891011121314151617// 边框颜色self.iconView.layer.borderColor = [UIColor orangeColor].CGColor;// 边框宽度self.iconView.layer.borderWidth = 10;// 圆角半径self.iconView.layer.cornerRadius = 10;// 超出图层边框的内容裁剪掉self.iconView.layer.masksToBounds = YES;// 颜色self.iconView.layer.shadowColor = [UIColor blackColor].CGColor;// 偏移量self.iconView.layer.shadowOffset = CGSizeMake(10, 10);// 透明度self.iconView.layer.shadowOpacity = 0.5;// 内容self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 示例：实现UIImageView既能设置圆角,也能设置阴影? 思路：创建两个图层，一个负责圆角,一个负责阴影123456789101112131415161718// 创建背景图层用来设置阴影CALayer *bgLayer = [CALayer layer];bgLayer.frame = CGRectMake(100, 100, 100, 100);bgLayer.backgroundColor = [UIColor clearColor].CGColor;// 设置阴影bgLayer.shadowColor = [UIColor purpleColor].CGColor;bgLayer.shadowOffset = CGSizeMake(10, 10);bgLayer.shadowOpacity = 0.5;// 创建子图层负责显示图片和设置圆角CALayer *subLayer = [CALayer layer];subLayer.frame = bgLayer.bounds;subLayer.cornerRadius = 20;subLayer.masksToBounds = YES;subLayer.contents = (id) [UIImage imageNamed:@"girl.png"].CGImage;[bgLayer addSublayer:subLayer];[self.view.layer addSublayer:bgLayer]; 二、CALayer的transform属性1234567891011121314// 平移self.iconView.layer.transform = CATransform3DMakeTranslation(100, 100, 13210); //缩放self.iconView.layer.transform = CATransform3DMakeScale(0.5, 1, 100);// 旋转self.iconView.layer.transform = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);self.iconView.transform = CGAffineTransformMakeRotation(M_PI_4);// 旋转 100弧度[self.iconView.layer setValue:@(100) forKeyPath:@"transform.rotation.z"];// 全局缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale"];// 指定X轴方向缩放[self.iconView.layer setValue:@(2) forKeyPath:@"transform.scale.x"]; 注意：CALayer 还有一个锚点属性.anchorPoint，锚点默认是在图层的中心位置，如果改变锚点，会对图层position属性造成影响。 三、CALayer的隐式动画1234567891011//直接修改layer的大小、位置等一些属性会默认执行动画(subLayer为自定义创建的layer,添加在self.view.layer上)self.subLayer.position = CGPointMake(200, 200);self.subLayer.bounds = CGRectMake(0, 0, 250, 250);// 开启事务[CATransaction begin];// 禁止执行隐式动画[CATransaction setDisableActions:YES];self.subLayer.position = CGPointMake(200, 200);// 提交事务[CATransaction commit]; 我们自己写的动画都属于显式动画，当定义显示动画后，相应的隐式动画会自动取消。 四、CALayer可以动画的属性由于CALayer在iOS中任务主要是内容展示和动画操作，并且动画操作是CALayer的一个重要功能，因此CALayer很多属性的值在变化的时都有动画效果，这个就是我们之前提到的“隐式动画”（手动创建的CALayer对象，都存在着隐式动画），但UIView的根图层是一个例外，根图层属性修改的时候不形成动画效果，因为根图层充当容器的作用，如果它的属性变化形成动画效果会直接干扰子图层。另外，根图层是是由UIView管理，不能重新创建。 常用的图层属性请参照苹果开发文档中的CALayer Animatable Properties 注意：CALayer使用bounds和position属性，position在子图层的位置由anchorPoint决定，frame属性很少使用 CALayer透明度使用opacity，而不是alpha 五、CALayer的内容绘制1、使用图片为图层提供内容（适用于图层内容几乎不改变的情况）1self.iconView.layer.contents = (id)[UIImage imageNamed:@"girl.png"].CGImage; 2、使用代理提供图层内容如果图层内容是动态改变的，则可以使用代理对象在需要的时候提供图层并更新内容。图层显示的时候，从代理方法获取内容，代理方法主要有以下两个： - (void)displayLayer:(CALayer *)layer; - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 如果实现了displayLayer:方法，实现方法负责创建位图并赋值给contents属性如果实现了drawLayer: inContext:方法，Core Animation创建一个位图，创业一个用于绘制位图的上下文，并调用代理方法填充该位图，代理方法所需要做的是将内容画在图形上下文中。注意：代理对象必须实现以上两个方法之一，如果代理对象把以上两个法都实现了，那么图层需要内容的时候，只调用displayLayer:代理方法。]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Animation]]></title>
    <url>%2F2017%2F08%2F16%2FCore-Animation%2F</url>
    <content type="text"><![CDATA[CoreAnimation是iOS与OS X平台上负责图形渲染与动画的基础设施。Core Animation可以动画视图和其他的可视元素，为你完成了动画所需的大部分绘帧工作。只需配置少量的动画参数（如开始点位置和结束点的位置）就可实现绚丽的Core Animation动画效果。 Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且更加的平滑，而且不会加重CPU的负担而影响程序的运行速度。 Core Animation自身并不是一个绘图系统。它只是一个负责在硬件上合成和操纵应用内容的基础构件。Core Animation的核心是图层对象，图层对象用于管理和操控你的应用内容。图层将捕获的内容放到一副位图中，图形硬件能够非常容易的操控你的位图。 当我们平时使用UIView动画不能满足需求的时候，可以直接对UIView的内容绘制的layer进行操作，Core Animation是UIview动画底层的实现，是对CALayer进行操作，所以Core Animation操作的对象是CALayer，而不是UIView。 Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程(执行动画的时候还能点击UI其它控件触发别的事件）。 CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用 CABasicAnimation：基本动画，通过属性修改进行动画参数控制，只有初始状态和结束状态CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行CATransition：转场动画，主要通过滤镜进行动画效果设置 一、CABasicAnimation1234567891011121314151617181920212223CABasicAnimation *anim = [CABasicAnimation animation];// 通过keyPath来告诉layer要执行怎样的动画(旋转,平移,缩放)，该属性必须是layer的一个属性anim.keyPath = @"transform.scale.x";// anim.keyPath = @"transform.rotation.z";// anim.keyPath = @"position"; // anim.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 200)];// anim.keyPath = @"bounds"; // anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 250, 250)];// anim.keyPath = @"transform"; // anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_4, 0, 0, 1)];anim.fromValue = @(4);anim.toValue = @(1.5);// 还可以设置成颜色变化// anim.toValue = (id)[UIColor redColor].CGColor;// 动画结束后不要移除动画效果anim.removedOnCompletion = NO;// 保持动画执行后的状态anim.fillMode = kCAFillModeBoth;// 设置动画的执行时间 （当前动画时间 + 延迟2s执行）anim.beginTime = CACurrentMediaTime() + 2;[self.blueView.layer addAnimation:anim forKey:nil]; 二、CAKeyframeAnimation 1、做一个抖动效果123456789// 角度转换弧度的宏#define angle2Radian(angel) ((angel) * M_PI / 180.0)CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"];anim.values = @[@(angle2Radian(-3)),@(angle2Radian(3)),@(angle2Radian(-3))];anim.repeatCount = MAXFLOAT;anim.duration = 0.2f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;[self.redView.layer addAnimation:anim forKey:@"abc"]; 2、设置关键帧数组values 12345678910111213141516 CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 设置关键帧anim.values = @[[NSValue valueWithCGPoint:CGPointZero], [NSValue valueWithCGPoint:CGPointMake(200, 0)], [NSValue valueWithCGPoint:CGPointMake(200, 200)], [NSValue valueWithCGPoint:CGPointMake(0, 200)], [NSValue valueWithCGPoint:CGPointZero]];// 设置关键帧执行的时间点(每一个元素的取值范围是0到1,后面的值要大于前面的值)anim.keyTimes = @[@(0),@(0.1),@(0.5),@(0.8),@(1)];anim.duration = 2.0f;// 保持动画执行完毕的状态anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;// 设置动画执行节奏anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];[self.redView.layer addAnimation:anim forKey:nil]; 3、设置路径path12345678910CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建一个圆圈路径CGMutablePathRef path = CGPathCreateMutable();CGPathAddEllipseInRect(path, NULL, CGRectMake(100, 100, 250,250));anim.path = path;anim.duration = 2.0f;anim.removedOnCompletion = NO;anim.fillMode = kCAFillModeForwards;anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[self.redView.layer addAnimation:anim forKey:nil]; 三、CAAnimationGroup12345678910111213141516171819202122232425262728293031323334353637383940CAKeyframeAnimation *position = [CAKeyframeAnimation animationWithKeyPath:@"position"];// 创建路径CGMutablePathRef path = CGPathCreateMutable();// 起始CGPathMoveToPoint(path, NULL, startPoint.x, startPoint.y);// 创建关键控制点数组（数组存放CGRect, CGRect的x、y值作为控制点xy坐标值，width和height作为结束点的xy坐标值） NSMutableArray *pointArrs = [[NSMutableArray alloc] init]; CGFloat width = [UIScreen mainScreen].bounds.size.width / 2; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))]; [pointArrs addObject:NSStringFromCGRect(CGRectMake(width, 300, width, 300))];[pointArrs enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CGRect rect = CGRectFromString(obj); // 二阶贝塞尔曲线 CGPathAddQuadCurveToPoint(path, NULL, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);&#125;];// 结束CGPathAddQuadCurveToPoint(path, NULL, endPoint.x, endPoint.y, endPoint.x, endPoint.y);position.path = path;position.duration = 5.0;position.speed = 0.7;position.removedOnCompletion = NO;position.fillMode = kCAFillModeForwards;CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];scaleAnimation.duration = 1.2;scaleAnimation.beginTime = 0.f;scaleAnimation.fromValue = [NSNumber numberWithFloat:0.7];scaleAnimation.toValue = [NSNumber numberWithFloat:1.5];scaleAnimation.removedOnCompletion = _removedOnCompletion;scaleAnimation.fillMode = kCAFillModeForwards;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];animationGroup.duration = 5+3;animationGroup.removedOnCompletion = NO;animationGroup.fillMode = kCAFillModeForwards;animationGroup.delegate = self;animationGroup.animations = @[position,scaleAnimation];[self.layer addAnimation:animationGroup forKey:@"SpecialGiftCar"]; 四、CATransition12345678910// 1.创建动画对象CATransition *tran = [CATransition animation];// 2.设置转场效果tran.type = @"oglFlip";// 3.设置转场方向tran.subtype = kCATransitionFromRight;NSString *imagename = [NSString stringWithFormat:@"%d",self.index];self.imageView.image = [UIImage imageNamed:imagename];// 4.添加动画到图层上[self.imageView.layer addAnimation:tran forKey:nil]; 附：过渡效果fade //交叉淡化过渡(不支持过渡方向) kCATransitionFadepush //新视图把旧视图推出去 kCATransitionPushmoveIn //新视图移到旧视图上面 kCATransitionMoveInreveal //将旧视图移开,显示下面的新视图 kCATransitionReveal /**下面几个也是过渡效果，但它们是私有API效果，使用的时候要小心，可能会导致app审核不被通过*/cube //立方体翻滚效果oglFlip //上下左右翻转效果suckEffect //收缩效果，如一块布被抽走(不支持过渡方向)rippleEffect //滴水效果(不支持过渡方向)pageCurl //向上翻页效果pageUnCurl //向下翻页效果cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向)cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向)]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell实现多选、全选、全不选]]></title>
    <url>%2F2017%2F08%2F07%2FUITableViewCell%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%80%89%E3%80%81%E5%85%A8%E9%80%89%E3%80%81%E5%85%A8%E4%B8%8D%E9%80%89%2F</url>
    <content type="text"><![CDATA[使用场景之一：购物车的时候用到1、设置cell可多选属性1self.tableV.allowsMultipleSelection = YES; 2、设置cell选择状态1cell.selectionStyle = UITableViewCellSelectionStyleNone 3、在cell上自定义一个选择Button(自定义名为：checkBtn)，Button的selected属性跟cell里的selected的属性绑定。设置Button的两种状态：UIControlStateNormal和UIControlStateSelected的不同状态图片。1234- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; self.checkBtn.selected = selected;&#125; 4、获取所有被选中的cell的NSIndexPath数组1NSArray * selectRows = self.tableV.indexPathsForSelectedRows; 5、全选/取消全选1234567891011if (select) &#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionNone]; &#125; &#125;else&#123; for (NSInteger i =0; i&lt;self.dataArr.count; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:i]; [self.tableV deselectRowAtIndexPath:indexPath animated:YES]; &#125; &#125;]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天周末，兴致所致，有点强迫症的我还是想做一个素雅无任何广告的博客，用来记录一点生活和学习相关的东西，便有了此博客的诞生。 这是使用Github Pages + Hexo 搭建的博客。 在此感谢 Github , 感谢 Hexo , 感谢 Line 的博客搭建教学。 基础命令1、如何创建博客文章？ 1$ hexo new "搭建博客" 更多指令信息可查看文档: Writing 2、 清理缓存 1$ hexo clean 网页正常情况下可以忽略此条命令 3、 生成静态网页 1$ hexo generate 默认生成的静态网页放在public目录博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作只要输入hexo generate命令即可，hexo会帮我们完成转换。Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 语法说明 4、 开启预览访问端口 1$ hexo server 默认端口4000，’ctrl + c’关闭server 5、 将.deploy目录部署到GitHub 1$ hexo deploy 文档编辑1、写标题12### 一、我是标题#### 1、我也是标题 2、插入图片（图片可以托管在七牛上，也可以放在hexo的资源文件夹里）1![Image text](http://ouakkqmoq.bkt.clouddn.com/coreAnimation.png) 3、不完全显示文章内容，在适当位置添加“查看全部”按钮1&lt;!--more--&gt; 4、写代码123``` bash这里是代码内容(```)只有三个点，没有这个括号]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
</search>
